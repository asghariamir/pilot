<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Analyzer | Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    
    <style>
        /* Mathswell Color System */
        :root {
            --primary: #0f766e;
            --primary-light: #10b981;
            --background: #f7faf9;
            --interactive: #e6fffb;
            --text-primary: #212121;
            --text-muted: #4b5563;
            --accent-amber: #f59e0b;
            --accent-red: #dc2626;
            --success: #10b981;
            --info-bg: #e6fffb;
            --surface: #ffffff;
            --border: #e5e7eb;
            --blue: #1e40af;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Mathswell Navigation */
        .mathswell-nav {
            display: flex;
            justify-content: center;
            margin: 1rem 0 1.5rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .mw-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            font-weight: 700;
            font-size: 1rem;
            color: var(--primary);
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        
        .mw-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        /* Container and Layout */
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }
        
        .subtitle {
            text-align: center;
            color: var(--text-muted);
            margin-bottom: 2rem;
        }
        
        /* Tab Navigation */
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
        }
        
        .tab-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
            white-space: nowrap;
        }
        
        .tab-btn:hover {
            color: var(--primary);
            background: var(--interactive);
        }
        
        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--interactive);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Introduction Tab Styles */
        .hero-section {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, var(--interactive) 0%, rgba(230,255,251,0.3) 100%);
            border-radius: 12px;
            margin-bottom: 2rem;
        }
        
        .concept-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .concept-card {
            background: var(--surface);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.2s ease;
        }
        
        .concept-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .concept-card h3 {
            color: var(--primary);
            margin-bottom: 0.75rem;
            font-size: 1.2rem;
        }
        
        .demo-area {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        .demo-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        
        .demo-btn {
            padding: 0.75rem 2rem;
            border-radius: 999px;
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 1rem;
        }
        
        .demo-btn:hover {
            background: var(--interactive);
            transform: translateY(-2px);
        }
        
        .demo-btn.active {
            background: var(--primary);
            color: white;
        }
        
        /* Canvas Styles */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .canvas-wrapper::before {
            content: '';
            display: block;
            padding-top: 100%;
        }
        
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        #intro-canvas, #grid-canvas {
            border: 1.5px solid var(--border);
            z-index: 1;
        }
        
        #main-canvas {
            z-index: 2;
            cursor: crosshair;
        }
        
        #handle-canvas {
            z-index: 3;
            pointer-events: none;
        }
        
        /* Explorer Tab Styles */
        .explorer-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: start;
        }
        
        @media (max-width: 900px) {
            .explorer-layout {
                grid-template-columns: 1fr;
            }
        }
        
        .controls-panel {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        
        .control-group {
            background: var(--interactive);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .control-group h4 {
            color: var(--primary);
            margin-bottom: 0.75rem;
        }
        
        .button-group {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        /* Interval Selector */
        .interval-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            font-family: 'Monaco', monospace;
            font-size: 1.1rem;
        }
        
        .interval-bracket {
            font-size: 1.5rem;
            color: var(--primary);
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            padding: 0 0.25rem;
            transition: all 0.2s ease;
        }
        
        .interval-bracket:hover {
            transform: scale(1.2);
            color: var(--accent-amber);
        }
        
        .interval-bracket.selected-paren {
            color: var(--primary);
        }
        
        .interval-bracket.selected-bracket {
            color: var(--primary);
            font-weight: 900;
        }
        
        .interval-input {
            width: 80px;
            padding: 0.25rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            text-align: center;
            font-family: inherit;
        }
        
        .interval-infinity {
            padding: 0.25rem 0.5rem;
            background: var(--interactive);
            border: 1px solid var(--primary);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .interval-infinity.active {
            background: var(--primary);
            color: white;
        }
        
        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--primary-light);
            color: white;
        }
        
        .btn-danger {
            background: var(--accent-red);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            background: white;
            border-radius: 8px;
            overflow: hidden;
        }
        
        th {
            background: var(--interactive);
            color: var(--primary);
            padding: 0.75rem 0.5rem;
            text-align: center;
            font-weight: 600;
        }
        
        td {
            padding: 0.5rem;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }
        
        tr.selected-row {
            background: var(--interactive);
        }
        
        .drag-handle {
            cursor: grab;
            font-size: 1.25em;
            color: var(--text-muted);
            user-select: none;
        }
        
        /* Form Elements */
        select, input[type="number"] {
            padding: 0.3rem 0.5rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.9rem;
            width: 100%;
        }
        
        .input-group {
            display: flex;
            gap: 0.25rem;
        }
        
        /* Analysis Results */
        .analysis-results {
            background: var(--interactive);
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
            font-family: ui-monospace, monospace;
            font-size: 0.9rem;
            line-height: 1.8;
        }
        
        .analysis-results strong {
            color: var(--primary);
        }
        
        /* Challenge Section */
        .challenge-section {
            background: linear-gradient(135deg, #fff4e6 0%, #ffe4cc 100%);
            border: 2px solid var(--accent-amber);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .challenge-header h4 {
            color: var(--accent-amber);
            font-size: 1.2rem;
        }
        
        .challenge-number {
            background: var(--accent-amber);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 999px;
            font-weight: 600;
        }
        
        .challenge-content {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        
        .feedback-box {
            background: var(--interactive);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: none;
        }
        
        .feedback-box.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-10px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .info-display {
            background: var(--interactive);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'Monaco', monospace;
            margin-top: 1rem;
        }
        
        .nav-btn {
            background: var(--primary);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            margin-top: 1rem;
            transition: all 0.2s ease;
        }
        
        .nav-btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }
        
        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                border-radius: 0;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .tabs {
                gap: 0.25rem;
            }
            
            .tab-btn {
                padding: 0.5rem 1rem;
                font-size: 0.9rem;
            }
            
            .concept-cards {
                grid-template-columns: 1fr;
            }
            
            .demo-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Mathswell Navigation Badge -->
    <div class="mathswell-nav">
        <a href="/" class="mw-link">
            <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
            <span>MATHSWELL</span>
        </a>
    </div>
    
    <div class="container">
        <h1>📈 Function Analyzer</h1>
        <p class="subtitle">Build, test, and analyze mathematical functions interactively</p>
        
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="intro">Learn</button>
            <button class="tab-btn" data-tab="explorer">Build & Challenge</button>
        </div>
        
        <!-- Introduction Tab -->
        <div id="intro" class="tab-content active">
            <div class="hero-section">
                <h2>What Makes a Function?</h2>
                <p>A function is a special relationship where each input (x-value) has exactly one output (y-value). Think of it as a machine that always gives the same result for the same input!</p>
            </div>
            
            <div class="concept-cards">
                <div class="concept-card">
                    <h3>📊 The Vertical Line Test</h3>
                    <p>If any vertical line crosses a graph more than once, it's not a function. Why? Because that x-value would have multiple y-values!</p>
                    <div class="info-display">
                        <strong>Key Rule:</strong> One input → One output
                    </div>
                </div>
                
                <div class="concept-card">
                    <h3>🎯 Domain & Range</h3>
                    <p><strong>Domain:</strong> All possible x-values (inputs)<br>
                    <strong>Range:</strong> All possible y-values (outputs)</p>
                    <div class="info-display">
                        Example: f(x) = x²<br>
                        Domain: (-∞, ∞)<br>
                        Range: [0, ∞)
                    </div>
                </div>
                
                <div class="concept-card">
                    <h3>📈 Function Behavior</h3>
                    <p>Functions can be:<br>
                    • <strong>Increasing:</strong> Going up ↗<br>
                    • <strong>Decreasing:</strong> Going down ↘<br>
                    • <strong>Constant:</strong> Staying flat →<br>
                    • <strong>Concave Up:</strong> Holds water ∪<br>
                    • <strong>Concave Down:</strong> Sheds water ∩</p>
                </div>
            </div>
            
            <div class="demo-area">
                <h3>Interactive Demo: Test Different Graphs!</h3>
                <div class="demo-buttons">
                    <button class="demo-btn active" onclick="switchDemoType('function')">✅ Functions</button>
                    <button class="demo-btn" onclick="switchDemoType('not-function')">❌ Not Functions</button>
                </div>
                
                <div class="canvas-wrapper">
                    <canvas id="intro-canvas"></canvas>
                </div>
                
                <div id="intro-result" class="info-display" style="text-align: center;">
                    <span id="demo-name" style="font-weight: bold;">Linear Function</span><br>
                    <span id="demo-description">✅ This IS a function! Every x has exactly one y.</span>
                </div>
                
                <div style="text-align: center; margin-top: 1rem;">
                    <button class="btn btn-secondary" onclick="nextDemoExample()">Next Example →</button>
                </div>
            </div>
            
            <div style="text-align: center;">
                <button class="nav-btn" onclick="switchTab('explorer')">
                    Start Building Functions →
                </button>
            </div>
        </div>
        
        <!-- Explorer & Challenge Tab -->
        <div id="explorer" class="tab-content">
            <div class="explorer-layout">
                <div class="controls-panel">
                    <div class="control-group">
                        <h4>🔧 Build Your Function</h4>
                        <div class="button-group">
                            <button id="add-segment" class="btn btn-primary">Add Segment</button>
                            <button id="undo-btn" class="btn btn-secondary">↶ Undo</button>
                            <button id="clear-all" class="btn btn-danger">Clear All</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h4>📝 Segments</h4>
                        <table id="segment-table">
                            <thead>
                                <tr>
                                    <th></th>
                                    <th>Type</th>
                                    <th>Domain</th>
                                    <th>Points</th>
                                    <th>Del</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                    
                    <div class="control-group">
                        <h4>🔍 Analysis</h4>
                        <button id="vline-btn" class="btn btn-primary">Animate Vertical Line Test</button>
                        <div id="analysis-results" class="analysis-results">
                            Add segments to begin analysis.
                        </div>
                    </div>
                </div>
                
                <div class="canvas-wrapper">
                    <canvas id="grid-canvas"></canvas>
                    <canvas id="main-canvas"></canvas>
                    <canvas id="handle-canvas"></canvas>
                </div>
            </div>
            
            <!-- Challenge Section -->
            <div class="challenge-section">
                <div class="challenge-header">
                    <h4>🎯 Function Challenge</h4>
                    <span class="challenge-number">Challenge <span id="challenge-num">1</span>/5</span>
                </div>
                
                <div class="challenge-content">
                    <p><strong>Build a function with these properties:</strong></p>
                    <ul id="requirements">
                        <li>Domain: [-5, 5]</li>
                        <li>Has at least one increasing interval</li>
                        <li>Has at least one decreasing interval</li>
                    </ul>
                </div>
                
                <div class="button-group">
                    <button id="check-challenge" class="btn btn-primary">Check My Function</button>
                    <button id="get-hint" class="btn btn-secondary">Get Hint</button>
                    <button id="new-challenge" class="btn btn-secondary">New Challenge</button>
                </div>
                
                <div id="challenge-feedback" class="feedback-box"></div>
            </div>
        </div>
    </div>
    
    <script>
        // State Management
        const DPR = window.devicePixelRatio || 1;
        const WMIN = -8, WMAX = 8, GRID = 1;
        
        const state = {
            segments: [],
            sel: null,
            undo: [],
            drag: { row: null, handle: false, curveIdx: null, vline: false },
            currentChallenge: 1,
            attempts: 0,
            demoType: 'function',
            demoIndex: 0,
            vlineAnimation: null,
            vlineX: WMIN
        };
        
        // Demo Examples
        const demoExamples = {
            'function': [
                {
                    name: 'Linear Function',
                    description: '✅ A straight line IS a function! It passes the vertical line test.',
                    draw: (ctx, size) => {
                        ctx.moveTo(size * 0.1, size * 0.8);
                        ctx.lineTo(size * 0.9, size * 0.2);
                    }
                },
                {
                    name: 'Parabola',
                    description: '✅ A parabola IS a function! Each x-value has exactly one y-value.',
                    draw: (ctx, size) => {
                        for (let x = -6; x <= 6; x += 0.1) {
                            const screenX = size * ((x + 8) / 16);
                            const y = (x * x) / 10 - 3;
                            const screenY = size * ((8 - y) / 16);
                            if (x === -6) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Absolute Value',
                    description: '✅ The V-shape IS a function! It has a sharp turn but still passes the test.',
                    draw: (ctx, size) => {
                        ctx.moveTo(size * 0.1, size * 0.2);
                        ctx.lineTo(size * 0.5, size * 0.8);
                        ctx.lineTo(size * 0.9, size * 0.2);
                    }
                },
                {
                    name: 'Cubic Function',
                    description: '✅ Cubic functions ARE functions! They can have twists but still pass the test.',
                    draw: (ctx, size) => {
                        for (let x = -4; x <= 4; x += 0.1) {
                            const screenX = size * ((x + 8) / 16);
                            const y = (x * x * x) / 20 + x / 2;
                            const screenY = size * ((8 - y) / 16);
                            if (x === -4) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Square Root',
                    description: '✅ The square root IS a function! It only takes the positive root.',
                    draw: (ctx, size) => {
                        for (let x = 0; x <= 8; x += 0.1) {
                            const screenX = size * ((x + 4) / 16);
                            const y = Math.sqrt(x) * 1.5 - 2;
                            const screenY = size * ((8 - y) / 16);
                            if (x === 0) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                }
            ],
            'not-function': [
                {
                    name: 'Circle',
                    description: '❌ A circle is NOT a function! Most x-values have two y-values.',
                    draw: (ctx, size) => {
                        ctx.arc(size / 2, size / 2, size * 0.3, 0, Math.PI * 2);
                    }
                },
                {
                    name: 'Sideways Parabola',
                    description: '❌ This is NOT a function! The vertical line crosses it twice.',
                    draw: (ctx, size) => {
                        for (let y = -4; y <= 4; y += 0.1) {
                            const x = (y * y) / 8;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (y === -4) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Ellipse',
                    description: '❌ An ellipse is NOT a function! It fails the vertical line test.',
                    draw: (ctx, size) => {
                        ctx.save();
                        ctx.translate(size / 2, size / 2);
                        ctx.scale(1.5, 1);
                        ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                        ctx.restore();
                    }
                },
                {
                    name: 'Figure Eight',
                    description: '❌ This is NOT a function! It crosses itself in the middle.',
                    draw: (ctx, size) => {
                        for (let t = 0; t <= Math.PI * 2; t += 0.05) {
                            const x = Math.sin(t) * 3;
                            const y = Math.sin(2 * t) * 3;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (t === 0) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Vertical Line',
                    description: '❌ A vertical line is NOT a function! One x has infinite y-values.',
                    draw: (ctx, size) => {
                        ctx.moveTo(size * 0.5, size * 0.1);
                        ctx.lineTo(size * 0.5, size * 0.9);
                    }
                }
            ]
        };
        
        // Tab Switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabName) {
                    btn.classList.add('active');
                }
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'explorer') {
                setTimeout(() => resize(), 100);
            }
        }
        
        // Tab event listeners
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
        
        // Introduction Tab Functions
        function switchDemoType(type) {
            state.demoType = type;
            state.demoIndex = 0;
            
            document.querySelectorAll('.demo-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(type === 'function' ? 'Functions' : 'Not Functions')) {
                    btn.classList.add('active');
                }
            });
            
            drawDemoExample();
        }
        
        function nextDemoExample() {
            const examples = demoExamples[state.demoType];
            state.demoIndex = (state.demoIndex + 1) % examples.length;
            drawDemoExample();
        }
        
        function drawDemoExample() {
            const canvas = document.getElementById('intro-canvas');
            const ctx = canvas.getContext('2d');
            const size = canvas.parentElement.getBoundingClientRect().width;
            
            canvas.width = size * DPR;
            canvas.height = size * DPR;
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            
            // Clear canvas
            ctx.clearRect(0, 0, size, size);
            
            // Draw grid
            drawIntroGrid(ctx, size);
            
            // Get current example
            const example = demoExamples[state.demoType][state.demoIndex];
            
            // Draw the graph
            ctx.strokeStyle = '#0f766e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            example.draw(ctx, size);
            ctx.stroke();
            
            // Draw animated vertical test line for non-functions
            if (state.demoType === 'not-function') {
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(size * 0.5, 0);
                ctx.lineTo(size * 0.5, size);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Update description
            document.getElementById('demo-name').textContent = example.name;
            document.getElementById('demo-description').textContent = example.description;
        }
        
        function drawIntroGrid(ctx, size) {
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            
            // Grid lines
            for (let i = 0; i <= 16; i++) {
                const pos = (i / 16) * size;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
        }
        
        // Explorer Tab Functions
        const gridCv = document.getElementById('grid-canvas');
        const mainCv = document.getElementById('main-canvas');
        const handleCv = document.getElementById('handle-canvas');
        const gCtx = gridCv.getContext('2d');
        const mCtx = mainCv.getContext('2d');
        const hCtx = handleCv.getContext('2d');
        
        const cssSize = cv => ({ w: cv.getBoundingClientRect().width, h: cv.getBoundingClientRect().height });
        const toScreen = (p, cvSize) => ({ x: (p.x - WMIN) / (WMAX - WMIN) * cvSize.w, y: (WMAX - p.y) / (WMAX - WMIN) * cvSize.h });
        const fromScreen = (c, cvSize) => ({ x: WMIN + c.x / cvSize.w * (WMAX - WMIN), y: WMAX - c.y / cvSize.h * (WMAX - WMIN) });
        const deep = obj => JSON.parse(JSON.stringify(obj));
        
        // Initialize
        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', resize);
        
        function init() {
            attachListeners();
            resize();
            pushUndo();
            
            // Add initial example segments
            state.segments.push({ 
                type: 'line', 
                p1: { x: -6, y: 2 }, 
                p2: { x: -1, y: 2 }, 
                startType: 'closed', 
                endType: 'open', 
                handleMode: 'auto', 
                handle: { x: -3.5, y: 4 } 
            });
            state.segments.push({ 
                type: 'curve', 
                p1: { x: -1, y: 3 }, 
                p2: { x: 4, y: -2 }, 
                startType: 'closed', 
                endType: 'closed', 
                handleMode: 'manual', 
                handle: { x: 1, y: 5 } 
            });
            state.sel = 1;
            refresh();
            
            // Load first demo example
            drawDemoExample();
            
            // Initialize challenge
            loadChallenge(1);
        }
        
        function resize() {
            const box = gridCv.parentElement.getBoundingClientRect();
            const size = box.width;
            [gridCv, mainCv, handleCv].forEach(cv => {
                cv.style.width = `${size}px`; 
                cv.style.height = `${size}px`;
                cv.width = size * DPR; 
                cv.height = size * DPR;
                cv.getContext('2d').setTransform(DPR, 0, 0, DPR, 0, 0);
            });
            drawAll();
        }
        
        function attachListeners() {
            document.getElementById('add-segment').addEventListener('click', addSegment);
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('clear-all').addEventListener('click', clearAll);
            document.getElementById('vline-btn').addEventListener('click', animateVerticalLine);
            document.querySelector('#segment-table tbody').addEventListener('input', onCellEdit);
            document.querySelector('#segment-table tbody').addEventListener('click', onTableClick);
            mainCv.addEventListener('mousedown', canvasDown);
            mainCv.addEventListener('mousemove', canvasMove);
            document.addEventListener('mouseup', canvasUp);
            mainCv.addEventListener('mouseleave', () => mainCv.style.cursor = 'crosshair');
            
            // Challenge listeners
            document.getElementById('check-challenge').addEventListener('click', checkChallenge);
            document.getElementById('get-hint').addEventListener('click', getHint);
            document.getElementById('new-challenge').addEventListener('click', () => loadChallenge(Math.floor(Math.random() * 5) + 1));
        }
        
        function refresh() {
            renderTable();
            drawAll();
            runAnalysis();
            document.getElementById('undo-btn').disabled = state.undo.length === 0;
        }
        
        function clearAll() {
            pushUndo();
            state.segments = [];
            state.sel = null;
            refresh();
        }
        
        function addSegment() {
            pushUndo();
            const last = state.segments[state.segments.length - 1];
            const start = last ? deep(last.p2) : { x: -2, y: 1 };
            state.segments.push({
                type: "line",
                p1: start,
                p2: { x: start.x + 4, y: start.y },
                startType: "closed",
                endType: "closed",
                handleMode: "auto",
                handle: { x: start.x + 2, y: start.y }
            });
            state.sel = state.segments.length - 1;
            refresh();
        }
        
        function renderTable() {
            const tbody = document.querySelector("#segment-table tbody");
            tbody.innerHTML = "";
            state.segments.forEach((seg, i) => {
                const row = document.createElement("tr");
                row.className = i === state.sel ? "selected-row" : "";
                row.dataset.i = i;
                row.draggable = true;
                
                row.addEventListener("dragstart", e => {
                    state.drag.row = i;
                    row.classList.add("dragging-row");
                    e.dataTransfer.effectAllowed = "move";
                });
                
                row.addEventListener("dragover", e => {
                    e.preventDefault();
                    e.currentTarget.style.background = "#e6fffb";
                });
                
                row.addEventListener("dragleave", e => {
                    e.currentTarget.style.background = "";
                });
                
                row.addEventListener("drop", e => {
                    e.preventDefault();
                    e.currentTarget.style.background = "";
                    if (state.drag.row !== null && state.drag.row !== i) {
                        pushUndo();
                        const [draggedSeg] = state.segments.splice(state.drag.row, 1);
                        state.segments.splice(i, 0, draggedSeg);
                        state.sel = i;
                        refresh();
                    }
                });
                
                row.addEventListener("dragend", () => {
                    document.querySelectorAll("#segment-table tr").forEach(r => r.classList.remove("dragging-row"));
                    state.drag.row = null;
                });
                
                row.addEventListener("click", e => {
                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "SELECT" && e.target.tagName !== "BUTTON" && e.target.tagName !== "SPAN") {
                        state.sel = i;
                        refresh();
                    }
                });
                
                const td = html => {
                    const cell = document.createElement("td");
                    cell.innerHTML = html;
                    return cell;
                };
                
                row.appendChild(td('<div class="drag-handle">☰</div>'));
                row.appendChild(td(`<select data-i="${i}" data-k="type">
                    <option value="line" ${seg.type === "line" ? "selected" : ""}>Line</option>
                    <option value="curve" ${seg.type === "curve" ? "selected" : ""}>Curve</option>
                </select>`));
                
                // Domain interval selector
                const domainCell = document.createElement("td");
                domainCell.innerHTML = `
                    <div class="interval-selector">
                        <span class="interval-bracket ${seg.startType === '-infty' ? 'selected-paren' : seg.startType === 'open' ? 'selected-paren' : 'selected-bracket'}" 
                              data-i="${i}" data-k="startType" data-type="${seg.startType}">
                            ${seg.startType === '-infty' ? '(' : seg.startType === 'open' ? '(' : '['}
                        </span>
                        ${seg.startType === '-infty' ? 
                            `<span class="interval-infinity active">-∞</span>` :
                            `<input type="number" class="interval-input" step="0.1" value="${seg.p1.x}" data-i="${i}" data-k="p1.x">`
                        }
                        <span>,</span>
                        ${seg.endType === '+infty' ? 
                            `<span class="interval-infinity active">+∞</span>` :
                            `<input type="number" class="interval-input" step="0.1" value="${seg.p2.x}" data-i="${i}" data-k="p2.x">`
                        }
                        <span class="interval-bracket ${seg.endType === '+infty' ? 'selected-paren' : seg.endType === 'open' ? 'selected-paren' : 'selected-bracket'}" 
                              data-i="${i}" data-k="endType" data-type="${seg.endType}">
                            ${seg.endType === '+infty' ? ')' : seg.endType === 'open' ? ')' : ']'}
                        </span>
                    </div>
                `;
                
                // Add click handlers for brackets
                domainCell.querySelectorAll('.interval-bracket').forEach(bracket => {
                    bracket.addEventListener('click', e => {
                        const key = e.target.dataset.k;
                        const currentType = e.target.dataset.type;
                        let newType;
                        
                        if (key === 'startType') {
                            if (currentType === '-infty') newType = 'open';
                            else if (currentType === 'open') newType = 'closed';
                            else newType = '-infty';
                        } else {
                            if (currentType === '+infty') newType = 'open';
                            else if (currentType === 'open') newType = 'closed';
                            else newType = '+infty';
                        }
                        
                        pushUndo();
                        seg[key] = newType;
                        refresh();
                    });
                });
                
                row.appendChild(domainCell);
                
                // Points and handle controls
                row.appendChild(td(`
                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                        <div class="input-group">
                            <input type="number" step="0.1" value="${seg.p1.y}" data-i="${i}" data-k="p1.y" 
                                   placeholder="y₁" style="width: 60px;">
                            <input type="number" step="0.1" value="${seg.p2.y}" data-i="${i}" data-k="p2.y" 
                                   placeholder="y₂" style="width: 60px;">
                        </div>
                        <select data-i="${i}" data-k="handleMode" style="width: 100%;">
                            <option value="auto" ${seg.handleMode === "auto" ? "selected" : ""}>Auto</option>
                            <option value="manual" ${seg.handleMode === "manual" ? "selected" : ""}>Manual</option>
                        </select>
                        ${seg.handleMode === "manual" ? `
                            <div class="input-group">
                                <input type="number" step="0.1" value="${seg.handle?.x ?? ""}" 
                                       data-i="${i}" data-k="handle.x" placeholder="hₓ" style="width: 60px;">
                                <input type="number" step="0.1" value="${seg.handle?.y ?? ""}" 
                                       data-i="${i}" data-k="handle.y" placeholder="hᵧ" style="width: 60px;">
                            </div>
                        ` : ''}
                    </div>
                `));
                
                row.appendChild(td(`<button class="btn btn-danger" style="padding: 0.25rem 0.5rem;" 
                                           data-act="del" data-i="${i}">✕</button>`));
                tbody.appendChild(row);
            });
        }
        
        function setVal(obj, path, val) {
            const keys = path.split(".");
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                current = current[keys[i]];
            }
            current[keys[keys.length - 1]] = val;
        }
        
        function onCellEdit(e) {
            const el = e.target;
            if (!el.dataset.k) return;
            pushUndo();
            const i = +el.dataset.i;
            const seg = state.segments[i];
            const val = el.tagName === "INPUT" ? parseFloat(el.value) : el.value;
            setVal(seg, el.dataset.k, val);
            if (seg.handleMode === "auto") {
                seg.handle = { x: (seg.p1.x + seg.p2.x) / 2, y: (seg.p1.y + seg.p2.y) / 2 };
            }
            refresh();
        }
        
        function onTableClick(e) {
            const btn = e.target.closest('button[data-act]');
            if (!btn) return;
            const i = +btn.dataset.i;
            if (btn.dataset.act === "del") {
                pushUndo();
                state.segments.splice(i, 1);
                state.sel = state.segments.length > 0 ? Math.max(0, i - 1) : null;
                refresh();
            }
        }
        
        function pushUndo() {
            state.undo.push(deep({ seg: state.segments, sel: state.sel }));
            document.getElementById('undo-btn').disabled = false;
        }
        
        function undo() {
            if (state.undo.length === 0) return;
            const prev = state.undo.pop();
            state.segments = prev.seg;
            state.sel = prev.sel;
            refresh();
        }
        
        function animateVerticalLine() {
            if (state.vlineAnimation) {
                clearInterval(state.vlineAnimation);
                state.vlineAnimation = null;
                state.vlineX = WMIN;
                drawAll();
                return;
            }
            
            state.vlineX = WMIN;
            state.vlineAnimation = setInterval(() => {
                state.vlineX += 0.1;
                if (state.vlineX > WMAX) {
                    state.vlineX = WMIN;
                }
                drawAll();
                drawVerticalTestLine();
            }, 50);
        }
        
        function drawVerticalTestLine() {
            const size = cssSize(mainCv);
            const screenX = toScreen({ x: state.vlineX, y: 0 }, size).x;
            
            mCtx.save();
            mCtx.strokeStyle = '#f59e0b';
            mCtx.lineWidth = 2.5;
            mCtx.setLineDash([5, 5]);
            mCtx.beginPath();
            mCtx.moveTo(screenX, 0);
            mCtx.lineTo(screenX, size.h);
            mCtx.stroke();
            mCtx.setLineDash([]);
            mCtx.restore();
        }
        
        // Drawing functions
        function drawGrid() {
            const size = cssSize(gridCv);
            gCtx.clearRect(0, 0, size.w, size.h);
            gCtx.strokeStyle = "#e5e7eb";
            gCtx.lineWidth = 1;
            
            for (let x = Math.ceil(WMIN); x <= Math.floor(WMAX); x += GRID) {
                const screen = toScreen({ x: x, y: 0 }, size);
                gCtx.beginPath();
                gCtx.moveTo(screen.x, 0);
                gCtx.lineTo(screen.x, size.h);
                gCtx.stroke();
            }
            
            for (let y = Math.ceil(WMIN); y <= Math.floor(WMAX); y += GRID) {
                const screen = toScreen({ x: 0, y: y }, size);
                gCtx.beginPath();
                gCtx.moveTo(0, screen.y);
                gCtx.lineTo(size.w, screen.y);
                gCtx.stroke();
            }
            
            const origin = toScreen({ x: 0, y: 0 }, size);
            gCtx.lineWidth = 1.5;
            gCtx.strokeStyle = "#94a3b8";
            gCtx.beginPath();
            gCtx.moveTo(0, origin.y);
            gCtx.lineTo(size.w, origin.y);
            gCtx.stroke();
            gCtx.beginPath();
            gCtx.moveTo(origin.x, 0);
            gCtx.lineTo(origin.x, size.h);
            gCtx.stroke();
        }
        
        function drawEndpoint(pt, type, ctx, size) {
            const screen = toScreen(pt, size);
            ctx.save();
            ctx.strokeStyle = "#1e40af";
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, 5, 0, 2 * Math.PI);
            if (type === "closed") {
                ctx.fillStyle = "#1e40af";
                ctx.fill();
            }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawHandle(p1Screen, p2Screen, handleScreen, hCtx) {
            hCtx.clearRect(0, 0, hCtx.canvas.width / DPR, hCtx.canvas.height / DPR);
            hCtx.beginPath();
            hCtx.setLineDash([3, 4]);
            hCtx.moveTo(p1Screen.x, p1Screen.y);
            hCtx.lineTo(handleScreen.x, handleScreen.y);
            hCtx.lineTo(p2Screen.x, p2Screen.y);
            hCtx.strokeStyle = "#10b981aa";
            hCtx.lineWidth = 1.5;
            hCtx.stroke();
            hCtx.setLineDash([]);
            hCtx.beginPath();
            hCtx.arc(handleScreen.x, handleScreen.y, 7, 0, 2 * Math.PI);
            hCtx.fillStyle = "#10b981";
            hCtx.fill();
            hCtx.strokeStyle = "#222";
            hCtx.lineWidth = 1;
            hCtx.stroke();
        }
        
        function drawSegment(seg, isSelected) {
            const size = cssSize(mainCv);
            
            mCtx.strokeStyle = isSelected ? "#f59e0b" : "#0f766e";
            mCtx.lineWidth = isSelected ? 3.5 : 2.5;
            
            const p1Screen = toScreen(seg.p1, size);
            const p2Screen = toScreen(seg.p2, size);
            const handleScreen = toScreen(seg.handle, size);
            
            mCtx.beginPath();
            mCtx.moveTo(p1Screen.x, p1Screen.y);
            
            if (seg.type === "line") {
                if (seg.handleMode === "manual") {
                    mCtx.lineTo(handleScreen.x, handleScreen.y);
                    mCtx.lineTo(p2Screen.x, p2Screen.y);
                } else {
                    mCtx.lineTo(p2Screen.x, p2Screen.y);
                }
            } else {
                const handle = seg.handleMode === "auto" 
                    ? { x: (seg.p1.x + seg.p2.x) / 2, y: (seg.p1.y + seg.p2.y) / 2 } 
                    : seg.handle;
                const hScreen = toScreen(handle, size);
                mCtx.quadraticCurveTo(hScreen.x, hScreen.y, p2Screen.x, p2Screen.y);
            }
            
            mCtx.stroke();
            
            if (isSelected && seg.handleMode === "manual") {
                drawHandle(p1Screen, p2Screen, handleScreen, hCtx);
            }
            
            if (seg.startType !== "-infty") {
                drawEndpoint(seg.p1, seg.startType, mCtx, size);
            }
            
            if (seg.endType !== "+infty") {
                drawEndpoint(seg.p2, seg.endType, mCtx, size);
            }
            
            if (seg.type === "line" && seg.handleMode === "manual") {
                drawEndpoint(seg.handle, "closed", mCtx, size);
            }
        }
        
        function drawAll() {
            const size = cssSize(mainCv);
            drawGrid();
            mCtx.clearRect(0, 0, size.w, size.h);
            hCtx.clearRect(0, 0, size.w, size.h);
            state.segments.forEach((seg, i) => drawSegment(seg, i === state.sel));
        }
        
        // Canvas interaction
        function mouseWorld(e) {
            const rect = mainCv.getBoundingClientRect();
            return fromScreen({ x: e.clientX - rect.left, y: e.clientY - rect.top }, cssSize(mainCv));
        }
        
        function handleHit(pt) {
            const thresh = 0.45;
            const idx = state.segments.findIndex((seg, i) => i === state.sel && seg.handleMode === "manual");
            if (idx !== -1) {
                const seg = state.segments[idx];
                const dx = pt.x - seg.handle.x;
                const dy = pt.y - seg.handle.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return idx;
                }
            }
            return -1;
        }
        
        function canvasDown(e) {
            const pt = mouseWorld(e);
            const handleIdx = handleHit(pt);
            if (handleIdx !== -1) {
                state.drag.handle = true;
                state.drag.curveIdx = handleIdx;
                mainCv.style.cursor = "grabbing";
            }
        }
        
        function canvasMove(e) {
            if (!state.drag.handle) return;
            const pt = mouseWorld(e);
            
            if (state.drag.handle) {
                state.segments[state.drag.curveIdx].handle.x = +pt.x.toFixed(2);
                state.segments[state.drag.curveIdx].handle.y = +pt.y.toFixed(2);
                refresh();
            }
        }
        
        function canvasUp() {
            if (state.drag.handle) {
                pushUndo();
            }
            state.drag = { row: null, handle: false, curveIdx: null, vline: false };
            mainCv.style.cursor = "crosshair";
        }
        
        // Complete Analysis function
        function runAnalysis() {
            const results = document.getElementById('analysis-results');
            const graphSegs = state.segments;
            
            if (graphSegs.length === 0) {
                results.innerHTML = 'Add segments to begin analysis.';
                return;
            }
            
            // Check if it's a function
            const checkIntervals = [];
            graphSegs.forEach(s => {
                if (s.type === 'line' && s.handleMode === 'manual') {
                    checkIntervals.push({ 
                        start: Math.min(s.p1.x, s.handle.x), 
                        end: Math.max(s.p1.x, s.handle.x) 
                    });
                    checkIntervals.push({ 
                        start: Math.min(s.handle.x, s.p2.x), 
                        end: Math.max(s.handle.x, s.p2.x) 
                    });
                } else {
                    checkIntervals.push({ 
                        start: Math.min(s.p1.x, s.p2.x), 
                        end: Math.max(s.p1.x, s.p2.x) 
                    });
                }
            });
            
            checkIntervals.sort((a, b) => a.start - b.start);
            let isFunction = true;
            for (let i = 1; i < checkIntervals.length; i++) {
                if (checkIntervals[i].start < checkIntervals[i - 1].end) {
                    isFunction = false;
                    break;
                }
            }
            
            if (!isFunction) {
                results.innerHTML = `<strong>Function test:</strong> <span style="color: var(--accent-red); font-weight: bold;">❌ Fails</span><br>The graph has overlapping segments and is not a function.`;
                return;
            }
            
            // Analyze all properties
            let increasing = [], decreasing = [], constant = [], concaveUp = [], concaveDown = [];
            let domainParts = [];
            let fullRange = [Infinity, -Infinity];
            
            graphSegs.sort((a, b) => Math.min(a.p1.x, a.p2.x) - Math.min(b.p1.x, b.p2.x));
            
            graphSegs.forEach(s => {
                domainParts.push({ 
                    start: s.p1.x, 
                    end: s.p2.x, 
                    startType: s.startType, 
                    endType: s.endType 
                });
                
                [s.p1, s.p2, s.handleMode === 'manual' && s.handle].filter(Boolean).forEach(p => {
                    fullRange[0] = Math.min(fullRange[0], p.y);
                    fullRange[1] = Math.max(fullRange[1], p.y);
                });
                
                if (s.type === 'line') {
                    const p1 = s.p1.x <= s.p2.x ? s.p1 : s.p2;
                    const p2 = s.p1.x <= s.p2.x ? s.p2 : s.p1;
                    const interval = {
                        start: p1.x,
                        end: p2.x,
                        startType: p1 === s.p1 ? s.startType : s.endType,
                        endType: p2 === s.p2 ? s.endType : s.startType
                    };
                    
                    if (Math.abs(p1.y - p2.y) < 1e-6) {
                        constant.push(interval);
                    } else if (p1.y < p2.y) {
                        increasing.push(interval);
                    } else {
                        decreasing.push(interval);
                    }
                    
                    // Lines have no concavity
                } else if (s.type === 'curve') {
                    // Analyze curve properties
                    const p1 = s.p1, p2 = s.p2;
                    const h = s.handleMode === 'auto' 
                        ? { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 } 
                        : s.handle;
                    
                    // Second derivative for concavity
                    const y_dd = 2 * (p1.y - 2 * h.y + p2.y);
                    const interval = {
                        start: Math.min(p1.x, p2.x),
                        end: Math.max(p1.x, p2.x),
                        startType: s.startType,
                        endType: s.endType
                    };
                    
                    if (Math.abs(y_dd) > 1e-6) {
                        if (y_dd > 0) concaveUp.push(interval);
                        else concaveDown.push(interval);
                    }
                    
                    // Check for critical points
                    const t_num = p1.y - h.y;
                    const t_den = p1.y - 2 * h.y + p2.y;
                    
                    if (Math.abs(t_den) < 1e-6) {
                        // Linear behavior
                        if (Math.abs(p1.y - p2.y) < 1e-6) {
                            constant.push(interval);
                        } else if ((p2.y > p1.y && p2.x > p1.x) || (p2.y < p1.y && p2.x < p1.x)) {
                            increasing.push(interval);
                        } else {
                            decreasing.push(interval);
                        }
                    } else {
                        const t = t_num / t_den;
                        if (t > 0.001 && t < 0.999) {
                            // Has a critical point
                            const xt = (1 - t) ** 2 * p1.x + 2 * (1 - t) * t * h.x + t ** 2 * p2.x;
                            const yt = (1 - t) ** 2 * p1.y + 2 * (1 - t) * t * h.y + t ** 2 * p2.y;
                            
                            const firstPart = {
                                start: Math.min(p1.x, xt),
                                end: Math.max(p1.x, xt),
                                startType: s.startType,
                                endType: 'closed'
                            };
                            const secondPart = {
                                start: Math.min(xt, p2.x),
                                end: Math.max(xt, p2.x),
                                startType: 'closed',
                                endType: s.endType
                            };
                            
                            if (yt > Math.max(p1.y, p2.y)) {
                                // Local maximum
                                increasing.push(firstPart);
                                decreasing.push(secondPart);
                            } else {
                                // Local minimum
                                decreasing.push(firstPart);
                                increasing.push(secondPart);
                            }
                        } else {
                            // Monotonic curve
                            if ((p2.y > p1.y && p2.x > p1.x) || (p2.y < p1.y && p2.x < p1.x)) {
                                increasing.push(interval);
                            } else {
                                decreasing.push(interval);
                            }
                        }
                    }
                }
            });
            
            function formatIntervals(arr) {
                if (arr.length === 0) return 'None';
                return arr.sort((a, b) => a.start - b.start).map(i => {
                    const open = i.startType === 'open' ? '(' : i.startType === '-infty' ? '(-∞' : '[';
                    const close = i.endType === 'open' ? ')' : i.endType === '+infty' ? '∞)' : ']';
                    const start = i.startType === '-infty' ? '' : i.start.toFixed(1);
                    const end = i.endType === '+infty' ? '' : i.end.toFixed(1);
                    return `${open}${start}, ${end}${close}`;
                }).join(' ∪ ');
            }
            
            results.innerHTML = `
                <strong>Function test:</strong> <span style="color: var(--success); font-weight: bold;">✅ Passes</span><br>
                <strong>Domain:</strong> ${formatIntervals(domainParts)}<br>
                <strong>Range:</strong> [${fullRange[0].toFixed(1)}, ${fullRange[1].toFixed(1)}]<br>
                <strong>Increasing:</strong> ${formatIntervals(increasing)}<br>
                <strong>Decreasing:</strong> ${formatIntervals(decreasing)}<br>
                <strong>Constant:</strong> ${formatIntervals(constant)}<br>
                <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br>
                <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}
            `.trim();
        }
        
        // Challenge Functions
        const challenges = [
            {
                requirements: [
                    "Domain: [-5, 5]",
                    "Has at least one increasing interval",
                    "Has at least one decreasing interval"
                ],
                hint: "Try creating a parabola or V-shape that goes up then down (or vice versa)!"
            },
            {
                requirements: [
                    "Domain includes (-∞, 3]",
                    "Range: [-2, 4]",
                    "Has a horizontal segment"
                ],
                hint: "Use a constant segment for the horizontal part. Set the start type to -∞ for the leftmost segment."
            },
            {
                requirements: [
                    "Has exactly 3 segments",
                    "Is always increasing",
                    "Contains at least one curve"
                ],
                hint: "Make sure each segment goes up from left to right. Use the curve type for smooth transitions."
            },
            {
                requirements: [
                    "Domain: [-4, 4]",
                    "Has a local maximum and minimum",
                    "Is concave up somewhere"
                ],
                hint: "You'll need curves to create local extrema. Adjust the handle to control concavity."
            },
            {
                requirements: [
                    "Passes through origin (0, 0)",
                    "Has both open and closed endpoints",
                    "Contains both increasing and decreasing parts"
                ],
                hint: "Make one of your segments pass through (0, 0). Click the interval brackets to toggle open/closed."
            }
        ];
        
        function loadChallenge(num) {
            state.currentChallenge = num;
            state.attempts = 0;
            const challenge = challenges[num - 1];
            
            document.getElementById('challenge-num').textContent = num;
            const reqList = document.getElementById('requirements');
            reqList.innerHTML = challenge.requirements.map(r => `<li>${r}</li>`).join('');
            
            document.getElementById('challenge-feedback').classList.remove('show');
        }
        
        function checkChallenge() {
            const feedback = document.getElementById('challenge-feedback');
            const challenge = challenges[state.currentChallenge - 1];
            
            // Analyze current function
            const analysis = document.getElementById('analysis-results').innerHTML;
            
            // Simple validation based on requirements
            let passed = true;
            let message = "✅ Excellent! Your function meets all requirements:<br>";
            
            challenge.requirements.forEach(req => {
                const reqLower = req.toLowerCase();
                if (reqLower.includes('domain') && !analysis.includes('Domain')) {
                    passed = false;
                } else if (reqLower.includes('increasing') && analysis.includes('Increasing: None')) {
                    passed = false;
                    message = "Your function needs an increasing interval. ";
                } else if (reqLower.includes('decreasing') && analysis.includes('Decreasing: None')) {
                    passed = false;
                    message = "Your function needs a decreasing interval. ";
                }
            });
            
            if (passed) {
                feedback.innerHTML = message + "Well done! Try a new challenge.";
                feedback.style.borderLeftColor = 'var(--success)';
            } else {
                feedback.innerHTML = "Not quite there yet. Check the analysis box above to see what's missing. " + 
                                   (state.attempts < 2 ? "Keep trying!" : "Click 'Get Hint' for help.");
                feedback.style.borderLeftColor = 'var(--accent-amber)';
            }
            
            feedback.classList.add('show');
            state.attempts++;
        }
        
        function getHint() {
            const feedback = document.getElementById('challenge-feedback');
            const challenge = challenges[state.currentChallenge - 1];
            
            feedback.innerHTML = `💡 Hint: ${challenge.hint}`;
            feedback.style.borderLeftColor = 'var(--primary)';
            feedback.classList.add('show');
        }
    </script>
</body>
</html>
