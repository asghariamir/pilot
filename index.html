<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Analyzer | Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    
    <style>
        /* Mathswell Color System */
        :root {
            --primary: #0f766e;
            --primary-light: #10b981;
            --background: #f7faf9;
            --interactive: #e6fffb;
            --text-primary: #212121;
            --text-muted: #4b5563;
            --accent-amber: #f59e0b;
            --accent-red: #dc2626;
            --success: #10b981;
            --surface: #ffffff;
            --border: #e5e7eb;
            --blue: #1e40af;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Mathswell Navigation */
        .mathswell-nav {
            display: flex;
            justify-content: center;
            margin: 1rem 0 1.5rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .mw-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            font-weight: 700;
            font-size: 1rem;
            color: var(--primary);
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        
        .mw-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }
        
        .subtitle {
            text-align: center;
            color: var(--text-muted);
            margin-bottom: 2rem;
        }
        
        /* Tabs - Centered */
        .tabs {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
        }
        
        .tab-btn {
            padding: 0.75rem 2rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .tab-btn:hover {
            color: var(--primary);
            background: var(--interactive);
        }
        
        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--interactive);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Introduction Tab */
        .hero-section {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, var(--interactive) 0%, rgba(230,255,251,0.3) 100%);
            border-radius: 12px;
            margin-bottom: 2rem;
        }
        
        .concept-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .concept-card {
            background: var(--surface);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.2s ease;
        }
        
        .concept-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .concept-card h3 {
            color: var(--primary);
            margin-bottom: 0.75rem;
            font-size: 1.2rem;
        }
        
        .demo-area {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        .demo-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .demo-btn {
            padding: 0.75rem 2rem;
            border-radius: 999px;
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 1rem;
        }
        
        .demo-btn:hover {
            background: var(--interactive);
            transform: translateY(-2px);
        }
        
        .demo-btn.active {
            background: var(--primary);
            color: white;
        }
        
        /* Canvas */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .canvas-wrapper::before {
            content: '';
            display: block;
            padding-top: 100%;
        }
        
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        #intro-canvas, #grid-canvas {
            border: 1.5px solid var(--border);
            z-index: 1;
        }
        
        #main-canvas {
            z-index: 2;
            cursor: crosshair;
        }
        
        #handle-canvas {
            z-index: 3;
        }
        
        /* Explorer Tab - Better Layout */
        .explorer-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: start;
        }
        
        @media (max-width: 900px) {
            .explorer-layout {
                grid-template-columns: 1fr;
            }
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .control-row {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .control-box {
            background: var(--interactive);
            border-radius: 8px;
            padding: 1rem;
        }
        
        .control-box h4 {
            color: var(--primary);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }
        
        /* Interval Selector */
        .interval-selector {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.5rem;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 1rem;
        }
        
        .interval-bracket {
            font-size: 1.4rem;
            color: var(--primary);
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            padding: 0 0.2rem;
            transition: all 0.2s ease;
        }
        
        .interval-bracket:hover {
            transform: scale(1.2);
            color: var(--accent-amber);
        }
        
        .interval-input {
            width: 60px;
            padding: 0.2rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            text-align: center;
            font-family: inherit;
            font-size: 0.9rem;
        }
        
        /* Buttons */
        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--primary-light);
            color: white;
        }
        
        .btn-danger {
            background: var(--accent-red);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Table */
        .table-container {
            max-height: 300px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: white;
        }
        
        th {
            background: var(--interactive);
            color: var(--primary);
            padding: 0.5rem 0.3rem;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        td {
            padding: 0.4rem 0.3rem;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }
        
        tr.selected-row {
            background: var(--interactive);
        }
        
        .drag-handle {
            cursor: grab;
            font-size: 1.1em;
            color: var(--text-muted);
            user-select: none;
        }
        
        /* Form Elements */
        select, input[type="number"], input[type="text"] {
            padding: 0.2rem 0.3rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.85rem;
            width: 100%;
        }
        
        .input-pair {
            display: flex;
            gap: 0.2rem;
        }
        
        /* Analysis Results */
        .analysis-results {
            background: var(--interactive);
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: ui-monospace, 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
        }
        
        .analysis-results strong {
            color: var(--primary);
        }
        
        /* Challenge Section */
        .challenge-section {
            background: linear-gradient(135deg, #fff4e6 0%, #ffe4cc 100%);
            border: 2px solid var(--accent-amber);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .challenge-header h4 {
            color: var(--accent-amber);
            font-size: 1.2rem;
        }
        
        .challenge-content {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            line-height: 1.8;
        }
        
        .challenge-requirement {
            padding: 0.3rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        .challenge-requirement:last-child {
            border-bottom: none;
        }
        
        .feedback-box {
            background: var(--interactive);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: none;
        }
        
        .feedback-box.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        .feedback-box.success {
            border-left-color: var(--success);
            background: #d1fae5;
        }
        
        .feedback-box.warning {
            border-left-color: var(--accent-amber);
            background: #fed7aa;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-10px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .info-display {
            background: var(--interactive);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'Monaco', monospace;
            margin-top: 1rem;
        }
        
        .violation-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--accent-red);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        /* Mobile */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                border-radius: 0;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .demo-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Mathswell Navigation Badge -->
    <div class="mathswell-nav">
        <a href="/" class="mw-link">
            <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
            <span>MATHSWELL</span>
        </a>
    </div>
    
    <div class="container">
        <h1>📈 Function Analyzer</h1>
        <p class="subtitle">Build, test, and analyze mathematical functions interactively</p>
        
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="intro">Learn</button>
            <button class="tab-btn" data-tab="explorer">Build & Challenge</button>
        </div>
        
        <!-- Introduction Tab -->
        <div id="intro" class="tab-content active">
            <div class="hero-section">
                <h2>What Makes a Function?</h2>
                <p>A function is a special relationship where each input (x-value) has exactly one output (y-value). The vertical line test helps us check this!</p>
            </div>
            
            <div class="concept-cards">
                <div class="concept-card">
                    <h3>📊 The Vertical Line Test</h3>
                    <p>If any vertical line crosses a graph more than once, it's not a function.</p>
                    <div class="info-display">
                        <strong>Key Rule:</strong> One input → One output
                    </div>
                </div>
                
                <div class="concept-card">
                    <h3>🎯 Domain & Range</h3>
                    <p><strong>Domain:</strong> All possible x-values<br>
                    <strong>Range:</strong> All possible y-values</p>
                    <div class="info-display">
                        Example: f(x) = x²<br>
                        Domain: (-∞, ∞)<br>
                        Range: [0, ∞)
                    </div>
                </div>
                
                <div class="concept-card">
                    <h3>📈 Function Behavior</h3>
                    <p>• <strong>Increasing:</strong> Going up ↗<br>
                    • <strong>Decreasing:</strong> Going down ↘<br>
                    • <strong>Constant:</strong> Staying flat →<br>
                    • <strong>Concave Up:</strong> Holds water ∪<br>
                    • <strong>Concave Down:</strong> Sheds water ∩</p>
                </div>
            </div>
            
            <div class="demo-area">
                <h3>Interactive Demo: Test Different Graphs!</h3>
                <div class="demo-controls">
                    <button class="demo-btn active" onclick="switchDemoType('function')">✅ Functions</button>
                    <button class="demo-btn" onclick="switchDemoType('not-function')">❌ Not Functions</button>
                    <button class="btn btn-secondary" onclick="nextDemoExample()">Next Example →</button>
                </div>
                
                <div class="canvas-wrapper" style="position: relative;">
                    <canvas id="intro-canvas"></canvas>
                    <div id="violation-indicator" class="violation-indicator" style="display: none;">
                        ❌ Multiple y-values!
                    </div>
                </div>
                
                <div id="intro-result" class="info-display" style="text-align: center;">
                    <span id="demo-name" style="font-weight: bold;">Loading...</span><br>
                    <span id="demo-description">Loading...</span>
                </div>
            </div>
        </div>
        
        <!-- Explorer & Challenge Tab -->
        <div id="explorer" class="tab-content">
            <div class="explorer-layout">
                <!-- Left Panel -->
                <div class="left-panel">
                    <!-- Build Controls -->
                    <div class="control-row">
                        <button id="add-segment" class="btn btn-primary">Add Segment</button>
                        <button id="undo-btn" class="btn btn-secondary">↶ Undo</button>
                        <button id="clear-all" class="btn btn-danger">Clear All</button>
                        <button id="vline-btn" class="btn btn-primary">Animate Vertical Line</button>
                    </div>
                    
                    <!-- Segments Table -->
                    <div class="control-box">
                        <h4>📝 Segments</h4>
                        <div class="table-container">
                            <table id="segment-table">
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th>Type</th>
                                        <th>Domain</th>
                                        <th>Y-Values</th>
                                        <th>Curve</th>
                                        <th>Del</th>
                                    </tr>
                                </thead>
                                <tbody></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- Analysis -->
                    <div class="control-box">
                        <h4>🔍 Analysis</h4>
                        <div id="analysis-results" class="analysis-results">
                            Add segments to begin analysis.
                        </div>
                    </div>
                </div>
                
                <!-- Right Panel - Canvas -->
                <div class="canvas-wrapper">
                    <canvas id="grid-canvas"></canvas>
                    <canvas id="main-canvas"></canvas>
                    <canvas id="handle-canvas"></canvas>
                </div>
            </div>
            
            <!-- AI Challenge Section -->
            <div class="challenge-section">
                <div class="challenge-header">
                    <h4>🎯 AI Function Challenge</h4>
                    <span id="challenge-badge" style="background: var(--accent-amber); color: white; padding: 0.25rem 0.75rem; border-radius: 999px; font-weight: 600;">
                        Dynamic Challenge
                    </span>
                </div>
                
                <div class="challenge-content">
                    <strong>Build a function with these properties:</strong>
                    <div id="requirements" style="margin-top: 0.5rem;">
                        Loading challenge...
                    </div>
                </div>
                
                <div class="control-row">
                    <button id="check-challenge" class="btn btn-primary">Check My Function</button>
                    <button id="get-hint" class="btn btn-secondary">Get Hint</button>
                    <button id="new-challenge" class="btn btn-secondary">New Challenge</button>
                </div>
                
                <div id="challenge-feedback" class="feedback-box"></div>
            </div>
        </div>
    </div>
    
    <script>
        // State Management
        const DPR = window.devicePixelRatio || 1;
        const WMIN = -8, WMAX = 8, GRID = 1;
        
        const state = {
            segments: [],
            sel: null,
            undo: [],
            drag: { 
                handle: false, 
                curveIdx: null,
                endpointIdx: null,
                endpointType: null // 'p1', 'p2', or 'handle'
            },
            demoType: 'function',
            demoIndex: 0,
            vlineAnimation: null,
            vlineX: WMIN,
            demoVlineX: WMIN,
            demoVlineAnimation: null,
            demoVlinePaused: false,
            currentChallenge: null,
            attempts: 0,
            showHandles: true
        };
        
        // Demo Examples - More Diverse
        const demoExamples = {
            'function': [
                {
                    name: 'Linear Function',
                    description: '✅ A straight line passes the vertical line test!',
                    draw: (ctx, size) => {
                        for (let x = -7; x <= 7; x += 0.1) {
                            const y = 0.8 * x - 1;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -7) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Step Function',
                    description: '✅ Jump discontinuities are allowed in functions!',
                    draw: (ctx, size) => {
                        // First step
                        for (let x = -6; x <= -2; x += 0.01) {
                            const y = -2;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -6) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                        ctx.stroke();
                        ctx.beginPath();
                        // Second step
                        for (let x = -2; x <= 2; x += 0.01) {
                            const y = 1;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -2) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                        ctx.stroke();
                        ctx.beginPath();
                        // Third step
                        for (let x = 2; x <= 6; x += 0.01) {
                            const y = 3;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === 2) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Parabola',
                    description: '✅ Each x-value has exactly one y-value.',
                    draw: (ctx, size) => {
                        for (let x = -6; x <= 6; x += 0.1) {
                            const y = 0.3 * x * x - 4;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -6) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Sine Wave',
                    description: '✅ Trigonometric functions are functions!',
                    draw: (ctx, size) => {
                        for (let x = -8; x <= 8; x += 0.1) {
                            const y = 3 * Math.sin(x);
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -8) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Exponential',
                    description: '✅ Exponential growth is a function!',
                    draw: (ctx, size) => {
                        for (let x = -6; x <= 3; x += 0.1) {
                            const y = Math.exp(x * 0.5) - 3;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -6) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                }
            ],
            'not-function': [
                {
                    name: 'Circle',
                    description: '❌ Most x-values have TWO y-values!',
                    draw: (ctx, size) => {
                        ctx.arc(size / 2, size / 2, size * 0.25, 0, Math.PI * 2);
                    },
                    violationX: 0 // Where to show violation
                },
                {
                    name: 'Sideways Parabola',
                    description: '❌ The vertical line crosses it multiple times!',
                    draw: (ctx, size) => {
                        for (let y = -5; y <= 5; y += 0.1) {
                            const x = 0.3 * y * y - 2;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (y === -5) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    },
                    violationX: 2
                },
                {
                    name: 'Figure Eight',
                    description: '❌ It crosses itself in the middle!',
                    draw: (ctx, size) => {
                        for (let t = 0; t <= Math.PI * 2; t += 0.05) {
                            const x = 3 * Math.sin(t);
                            const y = 3 * Math.sin(2 * t);
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (t === 0) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    },
                    violationX: 0
                },
                {
                    name: 'Vertical Line',
                    description: '❌ One x has INFINITE y-values!',
                    draw: (ctx, size) => {
                        const x = 2;
                        const screenX = size * ((x + 8) / 16);
                        ctx.moveTo(screenX, size * 0.1);
                        ctx.lineTo(screenX, size * 0.9);
                    },
                    violationX: 2
                }
            ]
        };
        
        // Tab Switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabName) {
                    btn.classList.add('active');
                }
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'explorer') {
                setTimeout(() => resize(), 100);
                if (!state.currentChallenge) {
                    generateNewChallenge();
                }
            }
        }
        
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
        
        // Demo Functions
        function switchDemoType(type) {
            state.demoType = type;
            state.demoIndex = 0;
            state.demoVlinePaused = false;
            
            document.querySelectorAll('.demo-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(type === 'function' ? 'Functions' : 'Not Functions')) {
                    btn.classList.add('active');
                }
            });
            
            // Start/stop vertical line animation based on type
            if (type === 'not-function') {
                startDemoVlineAnimation();
            } else {
                stopDemoVlineAnimation();
            }
            
            drawDemoExample();
        }
        
        function nextDemoExample() {
            const examples = demoExamples[state.demoType];
            state.demoIndex = (state.demoIndex + 1) % examples.length;
            state.demoVlinePaused = false;
            document.getElementById('violation-indicator').style.display = 'none';
            drawDemoExample();
        }
        
        function startDemoVlineAnimation() {
            if (state.demoVlineAnimation) return;
            state.demoVlineX = WMIN;
            state.demoVlinePaused = false;
            
            state.demoVlineAnimation = setInterval(() => {
                if (!state.demoVlinePaused) {
                    state.demoVlineX += 0.15;
                    if (state.demoVlineX > WMAX) {
                        state.demoVlineX = WMIN;
                        state.demoVlinePaused = false;
                        document.getElementById('violation-indicator').style.display = 'none';
                    }
                    
                    // Check if we're at a violation point
                    const example = demoExamples[state.demoType][state.demoIndex];
                    if (example.violationX !== undefined) {
                        const diff = Math.abs(state.demoVlineX - example.violationX);
                        if (diff < 0.3) {
                            state.demoVlinePaused = true;
                            document.getElementById('violation-indicator').style.display = 'block';
                            setTimeout(() => {
                                state.demoVlinePaused = false;
                                document.getElementById('violation-indicator').style.display = 'none';
                            }, 2000);
                        }
                    }
                }
                drawDemoExample();
            }, 50);
        }
        
        function stopDemoVlineAnimation() {
            if (state.demoVlineAnimation) {
                clearInterval(state.demoVlineAnimation);
                state.demoVlineAnimation = null;
                state.demoVlineX = WMIN;
                state.demoVlinePaused = false;
                document.getElementById('violation-indicator').style.display = 'none';
                drawDemoExample();
            }
        }
        
        function drawDemoExample() {
            const canvas = document.getElementById('intro-canvas');
            const ctx = canvas.getContext('2d');
            const size = canvas.parentElement.getBoundingClientRect().width;
            
            canvas.width = size * DPR;
            canvas.height = size * DPR;
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            
            ctx.clearRect(0, 0, size, size);
            
            // Draw grid
            drawIntroGrid(ctx, size);
            
            // Get current example
            const example = demoExamples[state.demoType][state.demoIndex];
            
            // Draw the graph
            ctx.strokeStyle = '#0f766e';
            ctx.lineWidth = 3;
            ctx.beginPath();
            example.draw(ctx, size);
            ctx.stroke();
            
            // Draw animated vertical test line for non-functions
            if (state.demoType === 'not-function') {
                const screenX = size * ((state.demoVlineX + 8) / 16);
                ctx.strokeStyle = state.demoVlinePaused ? '#dc2626' : '#f59e0b';
                ctx.lineWidth = state.demoVlinePaused ? 3 : 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, size);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Update description
            document.getElementById('demo-name').textContent = example.name;
            document.getElementById('demo-description').textContent = example.description;
        }
        
        function drawIntroGrid(ctx, size) {
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 16; i++) {
                const pos = (i / 16) * size;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
        }
        
        // Explorer Tab Functions
        const gridCv = document.getElementById('grid-canvas');
        const mainCv = document.getElementById('main-canvas');
        const handleCv = document.getElementById('handle-canvas');
        const gCtx = gridCv.getContext('2d');
        const mCtx = mainCv.getContext('2d');
        const hCtx = handleCv.getContext('2d');
        
        const cssSize = cv => ({ w: cv.getBoundingClientRect().width, h: cv.getBoundingClientRect().height });
        const toScreen = (p, cvSize) => ({ x: (p.x - WMIN) / (WMAX - WMIN) * cvSize.w, y: (WMAX - p.y) / (WMAX - WMIN) * cvSize.h });
        const fromScreen = (c, cvSize) => ({ x: WMIN + c.x / cvSize.w * (WMAX - WMIN), y: WMAX - c.y / cvSize.h * (WMAX - WMIN) });
        const deep = obj => JSON.parse(JSON.stringify(obj));
        
        // Initialize
        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', resize);
        
        function init() {
            attachListeners();
            resize();
            pushUndo();
            
            // Add initial example segments
            state.segments.push({ 
                type: 'line', 
                p1: { x: -6, y: 2 }, 
                p2: { x: -1, y: 2 }, 
                startType: 'closed', 
                endType: 'open', 
                handle: { x: -3.5, y: 4 } 
            });
            state.segments.push({ 
                type: 'curve', 
                p1: { x: -1, y: 3 }, 
                p2: { x: 4, y: -2 }, 
                startType: 'closed', 
                endType: 'closed', 
                handle: { x: 1, y: 5 } 
            });
            state.sel = 1;
            refresh();
            
            // Load first demo
            drawDemoExample();
        }
        
        function resize() {
            const boxes = [gridCv, mainCv, handleCv];
            boxes.forEach(cv => {
                if (!cv) return;
                const box = cv.parentElement?.getBoundingClientRect();
                if (!box) return;
                const size = box.width;
                cv.style.width = `${size}px`; 
                cv.style.height = `${size}px`;
                cv.width = size * DPR; 
                cv.height = size * DPR;
                cv.getContext('2d').setTransform(DPR, 0, 0, DPR, 0, 0);
            });
            drawAll();
        }
        
        function attachListeners() {
            document.getElementById('add-segment').addEventListener('click', addSegment);
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('clear-all').addEventListener('click', clearAll);
            document.getElementById('vline-btn').addEventListener('click', animateVerticalLine);
            document.querySelector('#segment-table tbody').addEventListener('input', onCellEdit);
            document.querySelector('#segment-table tbody').addEventListener('click', onTableClick);
            
            // Canvas mouse events
            handleCv.addEventListener('mousedown', canvasDown);
            handleCv.addEventListener('mousemove', canvasMove);
            document.addEventListener('mouseup', canvasUp);
            handleCv.addEventListener('mouseleave', () => handleCv.style.cursor = 'default');
            
            // Challenge listeners
            document.getElementById('check-challenge').addEventListener('click', checkChallenge);
            document.getElementById('get-hint').addEventListener('click', getHint);
            document.getElementById('new-challenge').addEventListener('click', generateNewChallenge);
        }
        
        function refresh() {
            renderTable();
            drawAll();
            runAnalysis();
            document.getElementById('undo-btn').disabled = state.undo.length === 0;
        }
        
        function clearAll() {
            pushUndo();
            state.segments = [];
            state.sel = null;
            refresh();
        }
        
        function addSegment() {
            pushUndo();
            const last = state.segments[state.segments.length - 1];
            const start = last ? deep(last.p2) : { x: -2, y: 1 };
            state.segments.push({
                type: "line",
                p1: start,
                p2: { x: start.x + 3, y: start.y + 1 },
                startType: "closed",
                endType: "closed",
                handle: { x: start.x + 1.5, y: start.y + 2 }
            });
            state.sel = state.segments.length - 1;
            refresh();
        }
        
        function renderTable() {
            const tbody = document.querySelector("#segment-table tbody");
            tbody.innerHTML = "";
            
            state.segments.forEach((seg, i) => {
                const row = document.createElement("tr");
                row.className = i === state.sel ? "selected-row" : "";
                
                row.addEventListener("click", e => {
                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "SELECT" && 
                        e.target.tagName !== "BUTTON" && !e.target.classList.contains('interval-bracket')) {
                        state.sel = i;
                        refresh();
                    }
                });
                
                const td = html => {
                    const cell = document.createElement("td");
                    cell.innerHTML = html;
                    return cell;
                };
                
                row.appendChild(td('<div class="drag-handle">☰</div>'));
                row.appendChild(td(`<select data-i="${i}" data-k="type">
                    <option value="line" ${seg.type === "line" ? "selected" : ""}>Line</option>
                    <option value="curve" ${seg.type === "curve" ? "selected" : ""}>Curve</option>
                </select>`));
                
                // Domain interval selector
                const domainCell = document.createElement("td");
                domainCell.innerHTML = `
                    <div class="interval-selector">
                        <span class="interval-bracket" data-i="${i}" data-k="startType">
                            ${seg.startType === '-infty' ? '(' : seg.startType === 'open' ? '(' : '['}
                        </span>
                        ${seg.startType === '-infty' ? 
                            `<span style="font-size: 0.9rem;">-∞</span>` :
                            `<input type="text" class="interval-input" value="${seg.p1.x}" 
                                   data-i="${i}" data-k="p1.x">`
                        }
                        <span>,</span>
                        ${seg.endType === '+infty' ? 
                            `<span style="font-size: 0.9rem;">+∞</span>` :
                            `<input type="text" class="interval-input" value="${seg.p2.x}" 
                                   data-i="${i}" data-k="p2.x">`
                        }
                        <span class="interval-bracket" data-i="${i}" data-k="endType">
                            ${seg.endType === '+infty' ? ')' : seg.endType === 'open' ? ')' : ']'}
                        </span>
                    </div>
                `;
                
                domainCell.querySelectorAll('.interval-bracket').forEach(bracket => {
                    bracket.addEventListener('click', e => {
                        const key = e.target.dataset.k;
                        const currentType = seg[key];
                        let newType;
                        
                        if (key === 'startType') {
                            newType = currentType === 'closed' ? 'open' : 
                                     currentType === 'open' ? '-infty' : 'closed';
                        } else {
                            newType = currentType === 'closed' ? 'open' : 
                                     currentType === 'open' ? '+infty' : 'closed';
                        }
                        
                        pushUndo();
                        seg[key] = newType;
                        refresh();
                    });
                });
                
                row.appendChild(domainCell);
                
                // Y-values
                row.appendChild(td(`
                    <div class="input-pair">
                        <input type="text" value="${seg.p1.y}" data-i="${i}" data-k="p1.y" 
                               style="width: 50px;">
                        <input type="text" value="${seg.p2.y}" data-i="${i}" data-k="p2.y" 
                               style="width: 50px;">
                    </div>
                `));
                
                // Curve controls
                row.appendChild(td(seg.type === 'curve' ? 
                    `<input type="checkbox" ${state.showHandles ? 'checked' : ''} 
                            onchange="state.showHandles = this.checked; drawAll()">` 
                    : '-'
                ));
                
                row.appendChild(td(`<button class="btn btn-danger" style="padding: 0.2rem 0.4rem; font-size: 0.8rem;" 
                                           data-act="del" data-i="${i}">✕</button>`));
                tbody.appendChild(row);
            });
        }
        
        function setVal(obj, path, val) {
            const keys = path.split(".");
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                current = current[keys[i]];
            }
            current[keys[keys.length - 1]] = val;
        }
        
        function onCellEdit(e) {
            const el = e.target;
            if (!el.dataset.k) return;
            
            const i = +el.dataset.i;
            const seg = state.segments[i];
            
            // For text inputs, allow negative numbers properly
            if (el.tagName === "INPUT") {
                const value = el.value.trim();
                // Allow empty or just minus sign while typing
                if (value === '' || value === '-') {
                    return; // Don't update yet, let user continue typing
                }
                const parsed = parseFloat(value);
                if (!isNaN(parsed)) {
                    pushUndo();
                    setVal(seg, el.dataset.k, parsed);
                    refresh();
                }
            } else {
                pushUndo();
                setVal(seg, el.dataset.k, el.value);
                refresh();
            }
        }
        
        function onTableClick(e) {
            const btn = e.target.closest('button[data-act]');
            if (!btn) return;
            const i = +btn.dataset.i;
            if (btn.dataset.act === "del") {
                pushUndo();
                state.segments.splice(i, 1);
                state.sel = state.segments.length > 0 ? Math.max(0, i - 1) : null;
                refresh();
            }
        }
        
        function pushUndo() {
            state.undo.push(deep({ seg: state.segments, sel: state.sel }));
            document.getElementById('undo-btn').disabled = false;
        }
        
        function undo() {
            if (state.undo.length === 0) return;
            const prev = state.undo.pop();
            state.segments = prev.seg;
            state.sel = prev.sel;
            refresh();
        }
        
        function animateVerticalLine() {
            if (state.vlineAnimation) {
                clearInterval(state.vlineAnimation);
                state.vlineAnimation = null;
                state.vlineX = WMIN;
                drawAll();
                document.getElementById('vline-btn').textContent = 'Animate Vertical Line';
                return;
            }
            
            state.vlineX = WMIN;
            document.getElementById('vline-btn').textContent = 'Stop Animation';
            state.vlineAnimation = setInterval(() => {
                state.vlineX += 0.1;
                if (state.vlineX > WMAX) {
                    state.vlineX = WMIN;
                }
                drawAll();
            }, 50);
        }
        
        // Drawing functions
        function drawGrid() {
            const size = cssSize(gridCv);
            gCtx.clearRect(0, 0, size.w, size.h);
            gCtx.strokeStyle = "#e5e7eb";
            gCtx.lineWidth = 1;
            
            for (let x = Math.ceil(WMIN); x <= Math.floor(WMAX); x += GRID) {
                const screen = toScreen({ x: x, y: 0 }, size);
                gCtx.beginPath();
                gCtx.moveTo(screen.x, 0);
                gCtx.lineTo(screen.x, size.h);
                gCtx.stroke();
            }
            
            for (let y = Math.ceil(WMIN); y <= Math.floor(WMAX); y += GRID) {
                const screen = toScreen({ x: 0, y: y }, size);
                gCtx.beginPath();
                gCtx.moveTo(0, screen.y);
                gCtx.lineTo(size.w, screen.y);
                gCtx.stroke();
            }
            
            const origin = toScreen({ x: 0, y: 0 }, size);
            gCtx.lineWidth = 1.5;
            gCtx.strokeStyle = "#94a3b8";
            gCtx.beginPath();
            gCtx.moveTo(0, origin.y);
            gCtx.lineTo(size.w, origin.y);
            gCtx.stroke();
            gCtx.beginPath();
            gCtx.moveTo(origin.x, 0);
            gCtx.lineTo(origin.x, size.h);
            gCtx.stroke();
        }
        
        function drawEndpoint(pt, type, ctx, size, isDraggable = false) {
            const screen = toScreen(pt, size);
            ctx.save();
            ctx.strokeStyle = isDraggable ? "#f59e0b" : "#1e40af";
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, isDraggable ? 7 : 5, 0, 2 * Math.PI);
            if (type === "closed") {
                ctx.fillStyle = isDraggable ? "#f59e0b" : "#1e40af";
                ctx.fill();
            }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawSegment(seg, isSelected) {
            const size = cssSize(mainCv);
            
            mCtx.strokeStyle = isSelected ? "#f59e0b" : "#0f766e";
            mCtx.lineWidth = isSelected ? 3.5 : 2.5;
            
            const p1Screen = toScreen(seg.p1, size);
            const p2Screen = toScreen(seg.p2, size);
            const handleScreen = toScreen(seg.handle, size);
            
            mCtx.beginPath();
            mCtx.moveTo(p1Screen.x, p1Screen.y);
            
            if (seg.type === "line") {
                mCtx.lineTo(p2Screen.x, p2Screen.y);
            } else {
                // Draw actual curve
                mCtx.quadraticCurveTo(handleScreen.x, handleScreen.y, p2Screen.x, p2Screen.y);
            }
            
            mCtx.stroke();
            
            // Draw endpoints
            if (seg.startType !== "-infty") {
                drawEndpoint(seg.p1, seg.startType, mCtx, size);
            }
            
            if (seg.endType !== "+infty") {
                drawEndpoint(seg.p2, seg.endType, mCtx, size);
            }
        }
        
        function drawHandles() {
            const size = cssSize(handleCv);
            hCtx.clearRect(0, 0, size.w, size.h);
            
            if (state.sel === null) return;
            const seg = state.segments[state.sel];
            
            // Draw draggable endpoints for y-value adjustment
            const p1Screen = toScreen(seg.p1, size);
            const p2Screen = toScreen(seg.p2, size);
            
            // Endpoint 1
            if (seg.startType !== "-infty") {
                hCtx.save();
                hCtx.fillStyle = "#f59e0b";
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.beginPath();
                hCtx.arc(p1Screen.x, p1Screen.y, 8, 0, 2 * Math.PI);
                hCtx.fill();
                hCtx.stroke();
                hCtx.restore();
            }
            
            // Endpoint 2
            if (seg.endType !== "+infty") {
                hCtx.save();
                hCtx.fillStyle = "#f59e0b";
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.beginPath();
                hCtx.arc(p2Screen.x, p2Screen.y, 8, 0, 2 * Math.PI);
                hCtx.fill();
                hCtx.stroke();
                hCtx.restore();
            }
            
            // Draw curve handle if it's a curve and handles are shown
            if (seg.type === 'curve' && state.showHandles) {
                const handleScreen = toScreen(seg.handle, size);
                
                // Draw guide lines
                hCtx.beginPath();
                hCtx.setLineDash([3, 4]);
                hCtx.moveTo(p1Screen.x, p1Screen.y);
                hCtx.lineTo(handleScreen.x, handleScreen.y);
                hCtx.lineTo(p2Screen.x, p2Screen.y);
                hCtx.strokeStyle = "#10b981aa";
                hCtx.lineWidth = 1.5;
                hCtx.stroke();
                hCtx.setLineDash([]);
                
                // Draw handle
                hCtx.beginPath();
                hCtx.arc(handleScreen.x, handleScreen.y, 8, 0, 2 * Math.PI);
                hCtx.fillStyle = "#10b981";
                hCtx.fill();
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.stroke();
            }
        }
        
        function drawAll() {
            const size = cssSize(mainCv);
            drawGrid();
            mCtx.clearRect(0, 0, size.w, size.h);
            state.segments.forEach((seg, i) => drawSegment(seg, i === state.sel));
            drawHandles();
            
            // Draw vertical line if animating
            if (state.vlineAnimation) {
                const screenX = toScreen({ x: state.vlineX, y: 0 }, size).x;
                mCtx.save();
                mCtx.strokeStyle = '#f59e0b';
                mCtx.lineWidth = 2.5;
                mCtx.setLineDash([5, 5]);
                mCtx.beginPath();
                mCtx.moveTo(screenX, 0);
                mCtx.lineTo(screenX, size.h);
                mCtx.stroke();
                mCtx.setLineDash([]);
                mCtx.restore();
            }
        }
        
        // Canvas interaction - Draggable endpoints and handles
        function mouseWorld(e) {
            const rect = handleCv.getBoundingClientRect();
            return fromScreen({ x: e.clientX - rect.left, y: e.clientY - rect.top }, cssSize(handleCv));
        }
        
        function getHitTarget(pt) {
            if (state.sel === null) return null;
            const seg = state.segments[state.sel];
            const thresh = 0.5;
            
            // Check endpoints
            if (seg.startType !== "-infty") {
                const dx = pt.x - seg.p1.x;
                const dy = pt.y - seg.p1.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return { type: 'p1', index: state.sel };
                }
            }
            
            if (seg.endType !== "+infty") {
                const dx = pt.x - seg.p2.x;
                const dy = pt.y - seg.p2.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return { type: 'p2', index: state.sel };
                }
            }
            
            // Check curve handle
            if (seg.type === 'curve' && state.showHandles) {
                const dx = pt.x - seg.handle.x;
                const dy = pt.y - seg.handle.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return { type: 'handle', index: state.sel };
                }
            }
            
            return null;
        }
        
        function canvasDown(e) {
            const pt = mouseWorld(e);
            const hit = getHitTarget(pt);
            
            if (hit) {
                state.drag.endpointIdx = hit.index;
                state.drag.endpointType = hit.type;
                handleCv.style.cursor = "grabbing";
            }
        }
        
        function canvasMove(e) {
            const pt = mouseWorld(e);
            
            if (state.drag.endpointIdx !== null) {
                // Dragging
                const seg = state.segments[state.drag.endpointIdx];
                
                if (state.drag.endpointType === 'p1') {
                    seg.p1.y = +pt.y.toFixed(2);
                } else if (state.drag.endpointType === 'p2') {
                    seg.p2.y = +pt.y.toFixed(2);
                } else if (state.drag.endpointType === 'handle') {
                    seg.handle.x = +pt.x.toFixed(2);
                    seg.handle.y = +pt.y.toFixed(2);
                }
                
                refresh();
            } else {
                // Hovering
                const hit = getHitTarget(pt);
                handleCv.style.cursor = hit ? "grab" : "default";
            }
        }
        
        function canvasUp() {
            if (state.drag.endpointIdx !== null) {
                pushUndo();
            }
            state.drag.endpointIdx = null;
            state.drag.endpointType = null;
            handleCv.style.cursor = "default";
        }
        
        // Analysis
        function runAnalysis() {
            const results = document.getElementById('analysis-results');
            const graphSegs = state.segments;
            
            if (graphSegs.length === 0) {
                results.innerHTML = 'Add segments to begin analysis.';
                return;
            }
            
            state.lastAnalysis = analyzeFunction(graphSegs);
            results.innerHTML = state.lastAnalysis.display;
        }
        
        function analyzeFunction(segments) {
            // Check if it's a function
            const checkIntervals = [];
            segments.forEach(s => {
                checkIntervals.push({ 
                    start: Math.min(s.p1.x, s.p2.x), 
                    end: Math.max(s.p1.x, s.p2.x) 
                });
            });
            
            checkIntervals.sort((a, b) => a.start - b.start);
            let isFunction = true;
            for (let i = 1; i < checkIntervals.length; i++) {
                if (checkIntervals[i].start < checkIntervals[i - 1].end) {
                    isFunction = false;
                    break;
                }
            }
            
            if (!isFunction) {
                return {
                    isFunction: false,
                    display: `<strong>Function test:</strong> <span style="color: var(--accent-red); font-weight: bold;">❌ Fails</span><br>The graph has overlapping segments.`
                };
            }
            
            // Analyze properties
            let increasing = [], decreasing = [], constant = [], concaveUp = [], concaveDown = [];
            let domainParts = [];
            let fullRange = [Infinity, -Infinity];
            
            segments.sort((a, b) => Math.min(a.p1.x, a.p2.x) - Math.min(b.p1.x, b.p2.x));
            
            segments.forEach(s => {
                domainParts.push({ 
                    start: s.p1.x, 
                    end: s.p2.x, 
                    startType: s.startType, 
                    endType: s.endType 
                });
                
                [s.p1, s.p2, s.handle].filter(Boolean).forEach(p => {
                    fullRange[0] = Math.min(fullRange[0], p.y);
                    fullRange[1] = Math.max(fullRange[1], p.y);
                });
                
                const p1 = s.p1.x <= s.p2.x ? s.p1 : s.p2;
                const p2 = s.p1.x <= s.p2.x ? s.p2 : s.p1;
                const interval = {
                    start: p1.x,
                    end: p2.x,
                    startType: p1 === s.p1 ? s.startType : s.endType,
                    endType: p2 === s.p2 ? s.endType : s.startType
                };
                
                if (s.type === 'line') {
                    if (Math.abs(p1.y - p2.y) < 1e-6) constant.push(interval);
                    else if (p1.y < p2.y) increasing.push(interval);
                    else decreasing.push(interval);
                } else if (s.type === 'curve') {
                    // Simple analysis for curves
                    const h = s.handle;
                    const y_dd = 2 * (s.p1.y - 2 * h.y + s.p2.y);
                    
                    if (Math.abs(y_dd) > 1e-6) {
                        if (y_dd > 0) concaveUp.push(interval);
                        else concaveDown.push(interval);
                    }
                    
                    // Monotonicity
                    if (Math.abs(p1.y - p2.y) < 1e-6) constant.push(interval);
                    else if (p1.y < p2.y) increasing.push(interval);
                    else decreasing.push(interval);
                }
            });
            
            function formatIntervals(arr) {
                if (arr.length === 0) return 'None';
                return arr.sort((a, b) => a.start - b.start).map(i => {
                    const open = i.startType === 'open' ? '(' : i.startType === '-infty' ? '(-∞' : '[';
                    const close = i.endType === 'open' ? ')' : i.endType === '+infty' ? '∞)' : ']';
                    const start = i.startType === '-infty' ? '' : i.start.toFixed(1);
                    const end = i.endType === '+infty' ? '' : i.end.toFixed(1);
                    return `${open}${start}, ${end}${close}`;
                }).join(' ∪ ');
            }
            
            return {
                isFunction: true,
                domain: formatIntervals(domainParts),
                range: `[${fullRange[0].toFixed(1)}, ${fullRange[1].toFixed(1)}]`,
                increasing: formatIntervals(increasing),
                decreasing: formatIntervals(decreasing),
                constant: formatIntervals(constant),
                concaveUp: formatIntervals(concaveUp),
                concaveDown: formatIntervals(concaveDown),
                hasIncreasing: increasing.length > 0,
                hasDecreasing: decreasing.length > 0,
                hasConstant: constant.length > 0,
                hasConcaveUp: concaveUp.length > 0,
                hasConcaveDown: concaveDown.length > 0,
                display: `
                    <strong>Function test:</strong> <span style="color: var(--success); font-weight: bold;">✅ Passes</span><br>
                    <strong>Domain:</strong> ${formatIntervals(domainParts)}<br>
                    <strong>Range:</strong> [${fullRange[0].toFixed(1)}, ${fullRange[1].toFixed(1)}]<br>
                    <strong>Increasing:</strong> ${formatIntervals(increasing)}<br>
                    <strong>Decreasing:</strong> ${formatIntervals(decreasing)}<br>
                    <strong>Constant:</strong> ${formatIntervals(constant)}<br>
                    <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br>
                    <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}
                `.trim()
            };
        }
        
        // AI Challenge Functions
        function generateNewChallenge() {
            const feedback = document.getElementById('challenge-feedback');
            feedback.classList.remove('show');
            state.attempts = 0;
            
            const challenges = [
                {
                    domain: `[-${Math.floor(Math.random() * 3 + 3)}, ${Math.floor(Math.random() * 3 + 3)}]`,
                    properties: ['an increasing interval', 'a decreasing interval']
                },
                {
                    domain: `(-∞, ${Math.floor(Math.random() * 3 + 2)}]`,
                    properties: ['a constant interval', 'bounded range']
                },
                {
                    domain: `[${Math.floor(Math.random() * 2 - 4)}, ${Math.floor(Math.random() * 2 + 4)}]`,
                    properties: ['a concave up interval (use curves!)', 'a local minimum']
                },
                {
                    domain: `[-${Math.floor(Math.random() * 2 + 2)}, ∞)`,
                    properties: ['always increasing', 'concave down somewhere']
                },
                {
                    domain: 'any interval',
                    properties: ['passes through origin (0,0)', 'both open and closed endpoints']
                }
            ];
            
            state.currentChallenge = challenges[Math.floor(Math.random() * challenges.length)];
            
            // Display challenge without bullet points
            const reqDiv = document.getElementById('requirements');
            let html = `<div class="challenge-requirement">Domain: ${state.currentChallenge.domain}</div>`;
            state.currentChallenge.properties.forEach(p => {
                html += `<div class="challenge-requirement">Has ${p}</div>`;
            });
            reqDiv.innerHTML = html;
        }
        
        function checkChallenge() {
            const feedback = document.getElementById('challenge-feedback');
            
            if (!state.lastAnalysis || !state.lastAnalysis.isFunction) {
                feedback.innerHTML = "❌ Your graph must be a valid function first!";
                feedback.className = 'feedback-box warning show';
                return;
            }
            
            let passed = true;
            let issues = [];
            
            state.currentChallenge.properties.forEach(prop => {
                if (prop.includes('increasing') && !state.lastAnalysis.hasIncreasing) {
                    passed = false;
                    issues.push("needs an increasing interval");
                }
                if (prop.includes('decreasing') && !state.lastAnalysis.hasDecreasing) {
                    passed = false;
                    issues.push("needs a decreasing interval");
                }
                if (prop.includes('constant') && !state.lastAnalysis.hasConstant) {
                    passed = false;
                    issues.push("needs a constant interval");
                }
                if (prop.includes('concave up') && !state.lastAnalysis.hasConcaveUp) {
                    passed = false;
                    issues.push("needs concave up (use curves!)");
                }
                if (prop.includes('concave down') && !state.lastAnalysis.hasConcaveDown) {
                    passed = false;
                    issues.push("needs concave down (use curves!)");
                }
            });
            
            if (passed) {
                feedback.innerHTML = `✅ Excellent! Your function meets all requirements!<br>Try a new challenge.`;
                feedback.className = 'feedback-box success show';
            } else {
                state.attempts++;
                feedback.innerHTML = `Your function ${issues.join(', ')}.<br>
                                     ${state.attempts > 1 ? "Check the analysis box for details." : "Keep trying!"}`;
                feedback.className = 'feedback-box warning show';
            }
        }
        
        function getHint() {
            const feedback = document.getElementById('challenge-feedback');
            const hints = [
                "Drag the endpoints up/down to change function behavior",
                "Drag the green handle to adjust curve shape",
                "Click brackets to toggle open/closed endpoints",
                "Constant means same y-value at both ends"
            ];
            
            feedback.innerHTML = `💡 ${hints[Math.floor(Math.random() * hints.length)]}`;
            feedback.className = 'feedback-box show';
        }
    </script>
</body>
</html>
