<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Function Behavior Cards | Mathswell</title>
  <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
  <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
  <style>
    :root {
      --primary: #0f766e;
      --primary-light: #10b981;
      --primary-dark: #0a5a52;
      --background: #f7faf9;
      --interactive: #e6fffb;
      --text-primary: #212121;
      --text-muted: #4b5563;
      --accent-amber: #f59e0b;
      --accent-red: #dc2626;
      --accent-blue: #2563eb;
      --surface: #ffffff;
      --border: #e0e7e4;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #dc2626;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--background) 0%, #f0f9f8 100%);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .mathswell-nav {
      display: flex;
      justify-content: center;
      margin: 1.5rem 0;
      padding: 0.5rem;
    }

    .mw-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      text-decoration: none;
      font-weight: 700;
      color: var(--primary);
      padding: 0.5rem 1rem;
      border-radius: 999px;
      background: #fff;
      box-shadow: 0 2px 8px rgba(15, 118, 110, 0.1);
      transition: all 0.3s ease;
    }

    .mw-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.2);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      background: white;
      border-radius: 12px;
      padding: 0.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      justify-content: center;
    }

    .tab-btn {
      padding: 0.75rem 1.5rem;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 8px;
      flex: 1;
      max-width: 200px;
    }

    .tab-btn:hover {
      background: var(--interactive);
      color: var(--primary);
    }

    .tab-btn.active {
      color: white;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      box-shadow: 0 2px 8px rgba(15, 118, 110, 0.15);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .hero {
      background: linear-gradient(135deg, #fff, var(--interactive));
      padding: 2.5rem;
      border-radius: 16px;
      margin-bottom: 2rem;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      text-align: center;
    }

    .hero h1 {
      color: var(--primary);
      margin-bottom: 1rem;
      font-size: 2.2rem;
      font-weight: 700;
    }

    .hero p {
      color: var(--text-muted);
      font-size: 1.1rem;
      max-width: 700px;
      margin: 0 auto;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .example-card {
      background: #fff;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      border: 1px solid var(--border);
      transition: all 0.3s ease;
    }

    .example-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
      border-color: var(--primary-light);
    }

    .example-card h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      font-size: 1.1rem;
      text-align: center;
    }

    .example-canvas {
      width: 100%;
      height: 120px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: #fff;
      margin-bottom: 0.5rem;
      display: block;
    }

    /* Card system styles */
    .card-bank {
      background: linear-gradient(135deg, var(--interactive), #f8fffe);
      padding: 1.5rem;
      border-radius: 12px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    }

    .card-bank h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      font-size: 1.2rem;
      text-align: center;
    }

    .cards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      min-height: 80px;
      justify-content: center;
    }

    /* Word cards for Tab 2 */
    .word-card {
      padding: 0.75rem 1.25rem;
      background: white;
      border: 2px solid var(--primary);
      border-radius: 999px;
      cursor: move;
      transition: all 0.3s ease;
      user-select: none;
      font-weight: 600;
      color: var(--primary);
    }

    .word-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.2);
      background: var(--interactive);
    }

    .word-card.dragging {
      opacity: 0.5;
    }

    /* Clickable image cards for Tab 3 */
    .clickable-card {
      width: 110px;
      height: 90px;
      background: white;
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .clickable-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.3);
    }

    .clickable-card.dragging {
      opacity: 0.5;
    }

    .clickable-card canvas {
      width: 100%;
      height: 60px;
      pointer-events: none;
    }

    .option-indicator {
      position: absolute;
      bottom: 2px;
      display: flex;
      gap: 2px;
    }

    .option-dot {
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #ddd;
    }

    .option-dot.active {
      background: var(--primary);
    }

    .sequence-area {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      margin-bottom: 2rem;
      min-height: 200px;
    }

    .sequence-area h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      text-align: center;
    }

    .sequence-container {
      display: flex;
      gap: 0.75rem;
      padding: 1.5rem;
      background: var(--interactive);
      border-radius: 8px;
      min-height: 100px;
      align-items: center;
      flex-wrap: wrap;
      border: 2px dashed var(--primary);
      justify-content: center;
    }

    .sequence-container.drag-over {
      background: #d1f4f0;
      border-color: var(--primary-light);
    }

    .graph-display {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      margin-bottom: 2rem;
    }

    .graph-display h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      text-align: center;
    }

    .graph-canvas {
      width: 100%;
      height: 350px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: white;
      display: block;
    }

    .controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.95rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(15, 118, 110, 0.3);
    }

    .btn-secondary {
      background: white;
      color: var(--primary);
      border: 2px solid var(--primary);
    }

    .btn-secondary:hover {
      background: var(--interactive);
    }

    .feedback {
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
      display: none;
      border-left: 4px solid;
      text-align: center;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .feedback.show {
      display: block;
    }

    .feedback.success {
      background: #d4edda;
      color: #155724;
      border-left-color: var(--success);
    }

    .feedback.error {
      background: #f8d7da;
      color: #721c24;
      border-left-color: var(--error);
    }

    .feedback.info {
      background: #cce5ff;
      color: #004085;
      border-left-color: var(--accent-blue);
    }

    .sentence-display {
      background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
      padding: 1.5rem;
      border-radius: 8px;
      margin-top: 1rem;
      font-size: 1.1rem;
      text-align: center;
      color: var(--primary-dark);
      animation: celebrate 0.5s ease;
    }

    @keyframes celebrate {
      0% { transform: scale(0.95); opacity: 0; }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }

    .challenge-box {
      background: linear-gradient(135deg, #fffbeb, #fef3c7);
      padding: 1.5rem;
      border-radius: 12px;
      border: 2px solid var(--accent-amber);
      margin-bottom: 2rem;
      text-align: center;
    }

    .challenge-box h4 {
      color: #92400e;
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    .challenge-text {
      color: #451a03;
      font-size: 1.2rem;
      font-weight: 600;
    }

    .placeholder-text {
      color: var(--text-muted);
      font-style: italic;
      text-align: center;
      padding: 2rem;
    }

    .hint-text {
      color: var(--text-muted);
      font-size: 0.9rem;
      text-align: center;
      margin-top: 0.5rem;
    }

    .ai-disclaimer {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
      font-style: italic;
      margin-top: 1rem;
      opacity: 0.7;
    }

    .cta-buttons {
      text-align: center;
      margin-top: 2rem;
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    @media (max-width: 768px) {
      .tabs {
        flex-direction: column;
      }
      
      .tab-btn {
        max-width: 100%;
      }
      
      .word-card {
        padding: 0.5rem 1rem;
        font-size: 0.9rem;
      }
      
      .clickable-card {
        width: 90px;
        height: 75px;
      }
    }
  </style>
</head>
<body>
  <div class="mathswell-nav">
    <a href="/" class="mw-link">
      <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
      <span>MATHSWELL</span>
    </a>
  </div>

  <div class="container">
    <div class="tabs">
      <button class="tab-btn active" data-tab="intro">Introduction</button>
      <button class="tab-btn" data-tab="read">Read the Graph</button>
      <button class="tab-btn" data-tab="build">Build from Behavior</button>
    </div>

    <!-- INTRODUCTION TAB -->
    <div id="intro" class="tab-content active">
      <div class="hero">
        <h1>Function Behavior Cards</h1>
        <p>Master function analysis by recognizing behaviors visually and describing them mathematically. Practice reading graphs and building functions from behavioral descriptions.</p>
      </div>

      <div class="examples-grid">
        <div class="example-card">
          <h3>Increasing</h3>
          <canvas class="example-canvas" id="ex-inc"></canvas>
        </div>
        <div class="example-card">
          <h3>Decreasing</h3>
          <canvas class="example-canvas" id="ex-dec"></canvas>
        </div>
        <div class="example-card">
          <h3>Concave Up</h3>
          <canvas class="example-canvas" id="ex-cup"></canvas>
        </div>
        <div class="example-card">
          <h3>Concave Down</h3>
          <canvas class="example-canvas" id="ex-cdown"></canvas>
        </div>
        <div class="example-card">
          <h3>Jump Discontinuity</h3>
          <canvas class="example-canvas" id="ex-jump"></canvas>
        </div>
        <div class="example-card">
          <h3>Inflection Point</h3>
          <canvas class="example-canvas" id="ex-inflect"></canvas>
        </div>
        <div class="example-card">
          <h3>Vertical Asymptote</h3>
          <canvas class="example-canvas" id="ex-vert"></canvas>
        </div>
        <div class="example-card">
          <h3>Horizontal Asymptote</h3>
          <canvas class="example-canvas" id="ex-horiz"></canvas>
        </div>
      </div>

      <div class="cta-buttons">
        <button class="btn btn-primary" onclick="switchToTab('read')">Try Reading Graphs →</button>
        <button class="btn btn-primary" onclick="switchToTab('build')">Build Functions →</button>
      </div>
    </div>

    <!-- READ THE GRAPH TAB -->
    <div id="read" class="tab-content">
      <div class="graph-display">
        <h3>Analyze This Function</h3>
        <canvas class="graph-canvas" id="read-graph"></canvas>
        <div class="controls">
          <button class="btn btn-secondary" onclick="generateNewReadProblem()">New Function</button>
        </div>
      </div>

      <div class="card-bank">
        <h3>Behavior Word Cards</h3>
        <p style="text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 1rem;">
          Drag words to describe each behavior change from left to right
        </p>
        <div class="cards-container" id="read-cards">
          <!-- Word cards will be generated here -->
        </div>
      </div>

      <div class="sequence-area">
        <h3>Your Description</h3>
        <div class="sequence-container" id="read-sequence">
          <div class="placeholder-text">Drag word cards here to describe the function from left to right</div>
        </div>
        <div class="controls">
          <button class="btn btn-primary" onclick="checkReadAnswer()">Check Answer</button>
          <button class="btn btn-secondary" onclick="clearReadSequence()">Clear</button>
          <button class="btn btn-secondary" onclick="getHint()">Hint</button>
        </div>
        <div class="feedback" id="read-feedback"></div>
        <div id="sentence-display"></div>
      </div>
    </div>

    <!-- BUILD FROM BEHAVIOR TAB -->
    <div id="build" class="tab-content">
      <div class="challenge-box">
        <h4>Build This Function:</h4>
        <div class="challenge-text" id="build-challenge">
          A function that starts low and ends high with upward curvature
        </div>
        <div class="controls">
          <button class="btn btn-secondary" onclick="generateNewBuildChallenge()">New Challenge</button>
        </div>
      </div>

      <div class="card-bank">
        <h3>Behavior Image Cards</h3>
        <p style="text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 1rem;">
          Click cards to cycle options, then drag to build the function
        </p>
        <div class="hint-text">Click each card to see different variations!</div>
        <div class="cards-container" id="build-cards">
          <!-- Clickable cards will be generated here -->
        </div>
      </div>

      <div class="sequence-area">
        <h3>Your Construction</h3>
        <div class="sequence-container" id="build-sequence">
          <div class="placeholder-text">Drag configured image cards here to build your function</div>
        </div>
        <div class="controls">
          <button class="btn btn-primary" onclick="checkBuildAnswer()">Check with AI</button>
          <button class="btn btn-secondary" onclick="clearBuildSequence()">Clear</button>
          <button class="btn btn-secondary" onclick="animateFunction()">Preview</button>
        </div>
        <div class="feedback" id="build-feedback"></div>
      </div>

      <div class="graph-display">
        <h3>Your Function Preview</h3>
        <canvas class="graph-canvas" id="build-graph"></canvas>
      </div>

      <p class="ai-disclaimer">
        AI assistance may occasionally be unavailable during high traffic periods.
      </p>
    </div>
  </div>

  <script>
    // Global state
    const state = {
      readProblem: null,
      readSequence: [],
      buildChallenge: null,
      buildSequence: [],
      draggedCard: null,
      hintCount: 0,
      cardStates: {} // Track the current option for each clickable card
    };

    // Card types with multiple options for Build tab
    const clickableCardTypes = [
      {
        id: 'increasing',
        options: [
          { id: 'inc-linear', draw: drawIncreasingLinear },
          { id: 'inc-cup', draw: drawIncreasingConcaveUp },
          { id: 'inc-cdown', draw: drawIncreasingConcaveDown }
        ]
      },
      {
        id: 'decreasing',
        options: [
          { id: 'dec-linear', draw: drawDecreasingLinear },
          { id: 'dec-cup', draw: drawDecreasingConcaveUp },
          { id: 'dec-cdown', draw: drawDecreasingConcaveDown }
        ]
      },
      {
        id: 'constant',
        options: [
          { id: 'const', draw: drawConstant }
        ]
      },
      {
        id: 'inflection',
        options: [
          { id: 'inflect-up-down', draw: drawInflectionUpDown },
          { id: 'inflect-down-up', draw: drawInflectionDownUp }
        ]
      },
      {
        id: 'jump',
        options: [
          { id: 'jump-up-left', draw: drawJumpUpLeft },
          { id: 'jump-up-right', draw: drawJumpUpRight },
          { id: 'jump-down-left', draw: drawJumpDownLeft },
          { id: 'jump-down-right', draw: drawJumpDownRight }
        ]
      },
      {
        id: 'v-asymptote',
        options: [
          { id: 'v-asym-left-up', draw: drawVertAsymLeftUp },
          { id: 'v-asym-left-down', draw: drawVertAsymLeftDown },
          { id: 'v-asym-right-up', draw: drawVertAsymRightUp },
          { id: 'v-asym-right-down', draw: drawVertAsymRightDown }
        ]
      },
      {
        id: 'h-asymptote',
        options: [
          { id: 'h-asym-from-above', draw: drawHorizAsymFromAbove },
          { id: 'h-asym-from-below', draw: drawHorizAsymFromBelow },
          { id: 'h-asym-to-above', draw: drawHorizAsymToAbove },
          { id: 'h-asym-to-below', draw: drawHorizAsymToBelow }
        ]
      }
    ];

    // Word behavior types for Read tab
    const behaviorTypes = [
      { id: 'increasing', label: 'Increasing' },
      { id: 'decreasing', label: 'Decreasing' },
      { id: 'constant', label: 'Constant' },
      { id: 'concave-up', label: 'Concave Up' },
      { id: 'concave-down', label: 'Concave Down' },
      { id: 'linear', label: 'Linear' },
      { id: 'inflection', label: 'Inflection Point' },
      { id: 'jump-up', label: 'Jump Up' },
      { id: 'jump-down', label: 'Jump Down' },
      { id: 'vertical-asymptote', label: 'Vertical Asymptote' },
      { id: 'horizontal-asymptote', label: 'Horizontal Asymptote' }
    ];

    // Drawing functions for clickable card options
    function drawIncreasingLinear(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.lineTo(w - 10, 10);
      ctx.stroke();
    }

    function drawIncreasingConcaveUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.quadraticCurveTo(30, h - 5, w - 10, 10);
      ctx.stroke();
    }

    function drawIncreasingConcaveDown(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.quadraticCurveTo(w - 30, 5, w - 10, 10);
      ctx.stroke();
    }

    function drawDecreasingLinear(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.lineTo(w - 10, h - 10);
      ctx.stroke();
    }

    function drawDecreasingConcaveUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.quadraticCurveTo(30, h - 5, w - 10, h - 10);
      ctx.stroke();
    }

    function drawDecreasingConcaveDown(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.quadraticCurveTo(w - 30, 5, w - 10, h - 10);
      ctx.stroke();
    }

    function drawConstant(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h/2);
      ctx.lineTo(w - 10, h/2);
      ctx.stroke();
    }

    function drawInflectionUpDown(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.bezierCurveTo(w/3, h - 20, w*2/3, 20, w - 10, 10);
      ctx.stroke();
      // Mark inflection
      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.arc(w/2, h/2, 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawInflectionDownUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.bezierCurveTo(w/3, 20, w*2/3, h - 20, w - 10, h - 10);
      ctx.stroke();
      // Mark inflection
      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.arc(w/2, h/2, 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawJumpUpLeft(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      // Left segment with filled circle
      ctx.beginPath();
      ctx.moveTo(10, h * 0.7);
      ctx.lineTo(w/2 - 5, h * 0.7);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 - 5, h * 0.7, 4, 0, 2 * Math.PI);
      ctx.fillStyle = '#0f766e';
      ctx.fill();
      // Right segment with open circle
      ctx.beginPath();
      ctx.moveTo(w/2 + 5, h * 0.3);
      ctx.lineTo(w - 10, h * 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 + 5, h * 0.3, 4, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.stroke();
    }

    function drawJumpUpRight(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      // Left segment with open circle
      ctx.beginPath();
      ctx.moveTo(10, h * 0.7);
      ctx.lineTo(w/2 - 5, h * 0.7);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 - 5, h * 0.7, 4, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.stroke();
      // Right segment with filled circle
      ctx.beginPath();
      ctx.moveTo(w/2 + 5, h * 0.3);
      ctx.lineTo(w - 10, h * 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 + 5, h * 0.3, 4, 0, 2 * Math.PI);
      ctx.fillStyle = '#0f766e';
      ctx.fill();
    }

    function drawJumpDownLeft(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      // Left segment with filled circle
      ctx.beginPath();
      ctx.moveTo(10, h * 0.3);
      ctx.lineTo(w/2 - 5, h * 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 - 5, h * 0.3, 4, 0, 2 * Math.PI);
      ctx.fillStyle = '#0f766e';
      ctx.fill();
      // Right segment with open circle
      ctx.beginPath();
      ctx.moveTo(w/2 + 5, h * 0.7);
      ctx.lineTo(w - 10, h * 0.7);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 + 5, h * 0.7, 4, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.stroke();
    }

    function drawJumpDownRight(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      // Left segment with open circle
      ctx.beginPath();
      ctx.moveTo(10, h * 0.3);
      ctx.lineTo(w/2 - 5, h * 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 - 5, h * 0.3, 4, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.stroke();
      // Right segment with filled circle
      ctx.beginPath();
      ctx.moveTo(w/2 + 5, h * 0.7);
      ctx.lineTo(w - 10, h * 0.7);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 + 5, h * 0.7, 4, 0, 2 * Math.PI);
      ctx.fillStyle = '#0f766e';
      ctx.fill();
    }

    function drawVertAsymLeftUp(ctx, w, h) {
      // Vertical line on right
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(w * 0.7, 5);
      ctx.lineTo(w * 0.7, h - 5);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve from left going up
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      ctx.moveTo(10, h * 0.7);
      for (let x = 10; x < w * 0.7 - 8; x += 3) {
        const t = (x - 10) / (w * 0.7 - 18);
        const y = h * 0.7 - h * 0.5 * Math.pow(t, 2);
        ctx.lineTo(x, Math.max(5, y));
      }
      ctx.stroke();
    }

    function drawVertAsymLeftDown(ctx, w, h) {
      // Vertical line on right
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(w * 0.7, 5);
      ctx.lineTo(w * 0.7, h - 5);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve from left going down
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      ctx.moveTo(10, h * 0.3);
      for (let x = 10; x < w * 0.7 - 8; x += 3) {
        const t = (x - 10) / (w * 0.7 - 18);
        const y = h * 0.3 + h * 0.5 * Math.pow(t, 2);
        ctx.lineTo(x, Math.min(h - 5, y));
      }
      ctx.stroke();
    }

    function drawVertAsymRightUp(ctx, w, h) {
      // Vertical line on left
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(w * 0.3, 5);
      ctx.lineTo(w * 0.3, h - 5);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve from right going up
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      ctx.moveTo(w - 10, h * 0.7);
      for (let x = w - 10; x > w * 0.3 + 8; x -= 3) {
        const t = (w - 10 - x) / (w - 10 - w * 0.3 - 8);
        const y = h * 0.7 - h * 0.5 * Math.pow(t, 2);
        ctx.lineTo(x, Math.max(5, y));
      }
      ctx.stroke();
    }

    function drawVertAsymRightDown(ctx, w, h) {
      // Vertical line on left
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(w * 0.3, 5);
      ctx.lineTo(w * 0.3, h - 5);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve from right going down
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      ctx.moveTo(w - 10, h * 0.3);
      for (let x = w - 10; x > w * 0.3 + 8; x -= 3) {
        const t = (w - 10 - x) / (w - 10 - w * 0.3 - 8);
        const y = h * 0.3 + h * 0.5 * Math.pow(t, 2);
        ctx.lineTo(x, Math.min(h - 5, y));
      }
      ctx.stroke();
    }

    function drawHorizAsymFromAbove(ctx, w, h) {
      // Horizontal line
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(5, h * 0.7);
      ctx.lineTo(w - 5, h * 0.7);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve approaching from above
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      ctx.moveTo(10, h * 0.2);
      for (let x = 10; x < w - 10; x += 3) {
        const t = (x - 10) / (w - 20);
        const y = h * 0.2 + (h * 0.7 - h * 0.2 - 5) * (1 - Math.exp(-3*t));
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function drawHorizAsymFromBelow(ctx, w, h) {
      // Horizontal line
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(5, h * 0.3);
      ctx.lineTo(w - 5, h * 0.3);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve approaching from below
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      ctx.moveTo(10, h * 0.8);
      for (let x = 10; x < w - 10; x += 3) {
        const t = (x - 10) / (w - 20);
        const y = h * 0.8 - (h * 0.8 - h * 0.3 - 5) * (1 - Math.exp(-3*t));
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function drawHorizAsymToAbove(ctx, w, h) {
      // Horizontal line
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(5, h * 0.3);
      ctx.lineTo(w - 5, h * 0.3);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve diverging upward
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      for (let x = w - 10; x > 10; x -= 3) {
        const t = (w - 10 - x) / (w - 20);
        const y = h * 0.3 + 5 + (h * 0.5) * (1 - Math.exp(-3*t));
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    function drawHorizAsymToBelow(ctx, w, h) {
      // Horizontal line
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 3;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.moveTo(5, h * 0.7);
      ctx.lineTo(w - 5, h * 0.7);
      ctx.stroke();
      ctx.setLineDash([]);
      // Curve diverging downward
      ctx.strokeStyle = '#0f766e';
      ctx.beginPath();
      for (let x = w - 10; x > 10; x -= 3) {
        const t = (w - 10 - x) / (w - 20);
        const y = h * 0.7 - 5 - (h * 0.5) * (1 - Math.exp(-3*t));
        ctx.lineTo(x, y);
      }
      ctx.stroke();
    }

    // Initialize example canvases
    function drawExamples() {
      const examples = [
        { id: 'ex-inc', func: drawIncreasingLinear },
        { id: 'ex-dec', func: drawDecreasingLinear },
        { id: 'ex-cup', func: drawIncreasingConcaveUp },
        { id: 'ex-cdown', func: drawDecreasingConcaveDown },
        { id: 'ex-jump', func: drawJumpUpRight },
        { id: 'ex-inflect', func: drawInflectionUpDown },
        { id: 'ex-vert', func: drawVertAsymLeftUp },
        { id: 'ex-horiz', func: drawHorizAsymFromBelow }
      ];

      examples.forEach(ex => {
        const canvas = document.getElementById(ex.id);
        if (canvas) {
          const ctx = canvas.getContext('2d');
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ex.func(ctx, canvas.width, canvas.height);
        }
      });
    }

    // Create word card for Tab 2
    function createWordCard(type) {
      const card = document.createElement('div');
      card.className = 'word-card';
      card.dataset.type = type.id;
      card.draggable = true;
      card.textContent = type.label;
      
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragend', handleDragEnd);
      
      return card;
    }

    // Create clickable image card for Tab 3
    function createClickableCard(cardType) {
      const card = document.createElement('div');
      card.className = 'clickable-card';
      card.dataset.cardId = cardType.id;
      card.dataset.optionIndex = '0';
      card.draggable = true;
      
      const canvas = document.createElement('canvas');
      card.appendChild(canvas);
      
      // Add option indicators
      const indicators = document.createElement('div');
      indicators.className = 'option-indicator';
      for (let i = 0; i < cardType.options.length; i++) {
        const dot = document.createElement('div');
        dot.className = 'option-dot' + (i === 0 ? ' active' : '');
        indicators.appendChild(dot);
      }
      card.appendChild(indicators);
      
      // Initialize card state
      state.cardStates[cardType.id] = 0;
      
      // Draw initial option
      setTimeout(() => {
        const ctx = canvas.getContext('2d');
        canvas.width = 90;
        canvas.height = 60;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        cardType.options[0].draw(ctx, canvas.width, canvas.height);
      }, 10);
      
      // Click to cycle options
      card.addEventListener('click', (e) => {
        if (e.target === card || e.target === canvas) {
          const currentIndex = parseInt(card.dataset.optionIndex);
          const nextIndex = (currentIndex + 1) % cardType.options.length;
          card.dataset.optionIndex = nextIndex.toString();
          state.cardStates[cardType.id] = nextIndex;
          
          // Update option indicators
          const dots = card.querySelectorAll('.option-dot');
          dots.forEach((dot, i) => {
            dot.classList.toggle('active', i === nextIndex);
          });
          
          // Redraw with new option
          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          cardType.options[nextIndex].draw(ctx, canvas.width, canvas.height);
        }
      });
      
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragend', handleDragEnd);
      
      return card;
    }

    // Drag and drop handlers
    function handleDragStart(e) {
      const card = e.target;
      let type;
      
      if (card.classList.contains('clickable-card')) {
        // For build tab - get the current option
        const cardId = card.dataset.cardId;
        const optionIndex = parseInt(card.dataset.optionIndex);
        const cardType = clickableCardTypes.find(ct => ct.id === cardId);
        type = cardType.options[optionIndex].id;
      } else {
        // For read tab - word cards
        type = card.dataset.type;
      }
      
      state.draggedCard = {
        type: type,
        element: card,
        fromSequence: card.parentElement.classList.contains('sequence-container'),
        isClickable: card.classList.contains('clickable-card'),
        cardId: card.dataset.cardId,
        optionIndex: card.dataset.optionIndex
      };
      
      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      state.draggedCard = null;
    }

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDragEnter(e) {
      if (e.target.classList.contains('sequence-container')) {
        e.target.classList.add('drag-over');
      }
    }

    function handleDragLeave(e) {
      if (e.target.classList.contains('sequence-container')) {
        e.target.classList.remove('drag-over');
      }
    }

    function handleDrop(e, sequenceType) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      const container = document.getElementById(`${sequenceType}-sequence`);
      container.classList.remove('drag-over');
      
      if (state.draggedCard) {
        const placeholder = container.querySelector('.placeholder-text');
        if (placeholder) {
          placeholder.remove();
        }
        
        if (sequenceType === 'read') {
          // Word card for Read tab
          const typeObj = behaviorTypes.find(t => t.id === state.draggedCard.type);
          if (typeObj) {
            const newCard = createWordCard(typeObj);
            container.appendChild(newCard);
            state.readSequence.push(state.draggedCard.type);
          }
        } else {
          // Image card for Build tab
          if (state.draggedCard.isClickable) {
            // Create a copy of the configured card
            const cardType = clickableCardTypes.find(ct => ct.id === state.draggedCard.cardId);
            const optionIndex = parseInt(state.draggedCard.optionIndex);
            const option = cardType.options[optionIndex];
            
            const card = document.createElement('div');
            card.className = 'clickable-card';
            card.dataset.type = option.id;
            card.draggable = true;
            
            const canvas = document.createElement('canvas');
            card.appendChild(canvas);
            
            setTimeout(() => {
              const ctx = canvas.getContext('2d');
              canvas.width = 90;
              canvas.height = 60;
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              option.draw(ctx, canvas.width, canvas.height);
            }, 10);
            
            card.addEventListener('dragstart', handleDragStart);
            card.addEventListener('dragend', handleDragEnd);
            
            container.appendChild(card);
            state.buildSequence.push(option.id);
            updateBuildGraph();
          }
        }
        
        // Remove from original if from sequence
        if (state.draggedCard.fromSequence) {
          state.draggedCard.element.remove();
          // Update sequence arrays
          if (sequenceType === 'read') {
            const idx = state.readSequence.indexOf(state.draggedCard.type);
            if (idx > -1) state.readSequence.splice(idx, 1);
          } else {
            const idx = state.buildSequence.indexOf(state.draggedCard.type);
            if (idx > -1) state.buildSequence.splice(idx, 1);
          }
        }
      }
      
      return false;
    }

    // Initialize Read tab with word cards
    function initializeReadTab() {
      const container = document.getElementById('read-cards');
      container.innerHTML = '';
      
      behaviorTypes.forEach(type => {
        const card = createWordCard(type);
        container.appendChild(card);
      });
      
      const sequence = document.getElementById('read-sequence');
      sequence.addEventListener('dragover', handleDragOver);
      sequence.addEventListener('drop', (e) => handleDrop(e, 'read'));
      sequence.addEventListener('dragenter', handleDragEnter);
      sequence.addEventListener('dragleave', handleDragLeave);
      
      generateNewReadProblem();
    }

    // Initialize Build tab with clickable cards
    function initializeBuildTab() {
      const container = document.getElementById('build-cards');
      container.innerHTML = '';
      
      clickableCardTypes.forEach(cardType => {
        const card = createClickableCard(cardType);
        container.appendChild(card);
      });
      
      const sequence = document.getElementById('build-sequence');
      sequence.addEventListener('dragover', handleDragOver);
      sequence.addEventListener('drop', (e) => handleDrop(e, 'build'));
      sequence.addEventListener('dragenter', handleDragEnter);
      sequence.addEventListener('dragleave', handleDragLeave);
      
      generateNewBuildChallenge();
      initializeBuildGraph();
    }

    // Read problems with proper intervals
    const readProblems = [
      { 
        sequence: ['increasing', 'concave-up'], 
        intervals: [['(-∞', '∞)'], ['(-∞', '∞)']],
        description: 'Increasing and concave up everywhere' 
      },
      { 
        sequence: ['decreasing', 'concave-down', 'inflection', 'decreasing', 'concave-up'], 
        intervals: [['(-∞', '0)'], ['(-∞', '0)'], ['x=0'], ['(0', '∞)'], ['(0', '∞)']],
        description: 'Decreasing with inflection at x=0' 
      },
      { 
        sequence: ['constant', 'jump-up', 'increasing'], 
        intervals: [['(-∞', '0)'], ['x=0'], ['(0', '∞)']],
        description: 'Constant then jump up, then increasing' 
      },
      { 
        sequence: ['increasing', 'concave-down', 'inflection', 'increasing', 'concave-up'], 
        intervals: [['(-∞', '0)'], ['(-∞', '0)'], ['x=0'], ['(0', '∞)'], ['(0', '∞)']],
        description: 'S-curve with inflection at origin' 
      },
      {
        sequence: ['decreasing', 'vertical-asymptote'],
        intervals: [['(-∞', '2)'], ['x=2']],
        description: 'Decreasing approaching vertical asymptote at x=2'
      },
      {
        sequence: ['increasing', 'horizontal-asymptote'],
        intervals: [['(-∞', '∞)'], ['y=3']],
        description: 'Increasing approaching horizontal asymptote y=3'
      }
    ];

    // Generate new Read problem
    function generateNewReadProblem() {
      state.readProblem = readProblems[Math.floor(Math.random() * readProblems.length)];
      state.hintCount = 0;
      drawReadGraph();
      clearReadSequence();
    }

    // Draw the graph for Read tab
    function drawReadGraph() {
      const canvas = document.getElementById('read-graph');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth || 800;
      canvas.height = 350;
      
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      drawGrid(ctx, w, h);
      
      // Draw based on problem type
      ctx.save();
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      
      const problem = state.readProblem;
      
      // Custom drawing for each problem type
      if (problem.description.includes('everywhere')) {
        // Simple increasing concave up
        ctx.beginPath();
        ctx.moveTo(50, h - 50);
        for (let x = 50; x < w - 50; x += 5) {
          const t = (x - 50) / (w - 100);
          const y = h - 50 - 200 * Math.pow(t, 2);
          ctx.lineTo(x, Math.max(50, y));
        }
        ctx.stroke();
      } else if (problem.description.includes('inflection at x=0')) {
        // S-curve through origin
        ctx.beginPath();
        for (let x = 50; x < w - 50; x += 5) {
          const t = (x - w/2) / 150;
          const y = h/2 - 100 * Math.tanh(t);
          if (x === 50) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        // Mark inflection
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(w/2, h/2, 6, 0, 2 * Math.PI);
        ctx.fill();
      } else if (problem.description.includes('jump up')) {
        // Constant then jump then increasing
        ctx.beginPath();
        ctx.moveTo(50, h * 0.6);
        ctx.lineTo(w/2 - 10, h * 0.6);
        ctx.stroke();
        // Jump
        ctx.beginPath();
        ctx.arc(w/2 - 10, h * 0.6, 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(w/2 + 10, h * 0.4, 5, 0, 2 * Math.PI);
        ctx.fillStyle = '#0f766e';
        ctx.fill();
        // Increasing part
        ctx.beginPath();
        ctx.moveTo(w/2 + 10, h * 0.4);
        ctx.lineTo(w - 50, h * 0.2);
        ctx.stroke();
      } else if (problem.description.includes('S-curve')) {
        // S-curve with clear concavity changes
        ctx.beginPath();
        for (let x = 50; x < w - 50; x += 5) {
          const t = (x - w/2) / 150;
          const y = h/2 - 80 * (t + 0.3 * Math.sin(2*t));
          if (x === 50) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        // Mark inflection
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(w/2, h/2, 6, 0, 2 * Math.PI);
        ctx.fill();
      } else if (problem.description.includes('vertical asymptote')) {
        // Vertical asymptote at x=2 (mapped to screen)
        const asymX = w * 0.6;
        ctx.strokeStyle = '#dc2626';
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(asymX, 30);
        ctx.lineTo(asymX, h - 30);
        ctx.stroke();
        ctx.setLineDash([]);
        // Function approaching
        ctx.strokeStyle = '#0f766e';
        ctx.beginPath();
        ctx.moveTo(50, h * 0.3);
        for (let x = 50; x < asymX - 10; x += 5) {
          const t = (x - 50) / (asymX - 60);
          const y = h * 0.3 + 150 * Math.pow(t, 3);
          ctx.lineTo(x, Math.min(h - 30, y));
        }
        ctx.stroke();
      } else if (problem.description.includes('horizontal asymptote')) {
        // Horizontal asymptote at y=3
        const asymY = h * 0.3;
        ctx.strokeStyle = '#dc2626';
        ctx.lineWidth = 3;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(50, asymY);
        ctx.lineTo(w - 50, asymY);
        ctx.stroke();
        ctx.setLineDash([]);
        // Function approaching
        ctx.strokeStyle = '#0f766e';
        ctx.beginPath();
        ctx.moveTo(50, h * 0.7);
        for (let x = 50; x < w - 50; x += 5) {
          const t = (x - 50) / (w - 100);
          const y = h * 0.7 - (h * 0.7 - asymY - 10) * (1 - Math.exp(-3*t));
          ctx.lineTo(x, y);
        }
        ctx.stroke();
      }
      
      ctx.restore();
    }

    // Draw grid
    function drawGrid(ctx, w, h) {
      ctx.strokeStyle = '#e8e8e8';
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= w; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      
      for (let y = 0; y <= h; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      
      // Axes
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(w/2, 0);
      ctx.lineTo(w/2, h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, h/2);
      ctx.lineTo(w, h/2);
      ctx.stroke();
    }

    // Clear sequences
    function clearReadSequence() {
      const container = document.getElementById('read-sequence');
      container.innerHTML = '<div class="placeholder-text">Drag word cards here to describe the function from left to right</div>';
      state.readSequence = [];
      document.getElementById('read-feedback').classList.remove('show');
      document.getElementById('sentence-display').innerHTML = '';
    }

    function clearBuildSequence() {
      const container = document.getElementById('build-sequence');
      container.innerHTML = '<div class="placeholder-text">Drag configured image cards here to build your function</div>';
      state.buildSequence = [];
      document.getElementById('build-feedback').classList.remove('show');
      updateBuildGraph();
    }

    // Get hint for Read tab
    function getHint() {
      const feedback = document.getElementById('read-feedback');
      state.hintCount++;
      
      if (state.hintCount === 1) {
        feedback.className = 'feedback info show';
        feedback.textContent = `Hint: Look for ${state.readProblem.sequence.length} behaviors/changes in the graph.`;
      } else if (state.hintCount === 2) {
        feedback.className = 'feedback info show';
        feedback.textContent = `Hint: The first behavior is "${state.readProblem.sequence[0].replace(/-/g, ' ')}".`;
      } else {
        feedback.className = 'feedback info show';
        const labels = state.readProblem.sequence.map(s => 
          behaviorTypes.find(t => t.id === s)?.label || s
        );
        feedback.textContent = `Answer: ${labels.join(' → ')}`;
      }
    }

    // Check Read answer
    function checkReadAnswer() {
      const feedback = document.getElementById('read-feedback');
      const sentenceDisplay = document.getElementById('sentence-display');
      
      if (state.readSequence.length === 0) {
        feedback.className = 'feedback error show';
        feedback.textContent = 'Please add behavior cards first.';
        return;
      }
      
      const correct = JSON.stringify(state.readSequence) === JSON.stringify(state.readProblem.sequence);
      
      if (correct) {
        feedback.className = 'feedback success show';
        feedback.textContent = 'Excellent! You correctly identified all behaviors!';
        
        // Generate complete sentence with intervals
        const sentence = generateSentence(state.readProblem);
        sentenceDisplay.className = 'sentence-display';
        sentenceDisplay.innerHTML = `<strong>Complete Description:</strong><br>${sentence}`;
        
        // Celebrate
        const cards = document.querySelectorAll('#read-sequence .word-card');
        cards.forEach((card, i) => {
          setTimeout(() => {
            card.style.transform = 'scale(1.1)';
            card.style.background = 'linear-gradient(135deg, #10b981, #0f766e)';
            card.style.color = 'white';
          }, i * 100);
        });
      } else {
        feedback.className = 'feedback error show';
        const missing = state.readProblem.sequence.length - state.readSequence.length;
        if (missing > 0) {
          feedback.textContent = `You're missing ${missing} behavior(s).`;
        } else if (missing < 0) {
          feedback.textContent = `Too many behaviors. You have ${-missing} extra card(s).`;
        } else {
          feedback.textContent = 'Not quite right. Check the order.';
        }
        sentenceDisplay.innerHTML = '';
      }
    }

    // Generate sentence from sequence with intervals
    function generateSentence(problem) {
      let sentence = "The function ";
      const behaviors = problem.sequence;
      const intervals = problem.intervals;
      
      behaviors.forEach((behavior, i) => {
        if (i > 0) sentence += ", ";
        
        const interval = intervals[i];
        const intervalStr = interval ? interval.join(', ') : "";
        
        const typeObj = behaviorTypes.find(t => t.id === behavior);
        const label = typeObj ? typeObj.label.toLowerCase() : behavior;
        
        if (behavior === 'inflection') {
          sentence += `has an inflection point at ${intervalStr}`;
        } else if (behavior.includes('jump')) {
          sentence += `has a ${label} discontinuity at ${intervalStr}`;
        } else if (behavior.includes('asymptote')) {
          sentence += `approaches a ${label} at ${intervalStr}`;
        } else {
          sentence += `is ${label} on ${intervalStr}`;
        }
      });
      
      sentence += ".";
      return sentence;
    }

    // Build challenges - more abstract descriptions
    const buildChallenges = [
      {
        description: "A function that starts low and ends high with upward curvature",
        expectedBehaviors: ['inc-cup']
      },
      {
        description: "A function that changes from falling to rising",
        expectedBehaviors: ['dec-cup', 'inc-cup']
      },
      {
        description: "A function with a sudden vertical displacement",
        expectedBehaviors: ['const', 'jump-up-right', 'inc-linear']
      },
      {
        description: "A function that changes its bending direction",
        expectedBehaviors: ['inc-cup', 'inflect-up-down', 'inc-cdown']
      },
      {
        description: "A function that approaches a limiting value",
        expectedBehaviors: ['inc-linear', 'h-asym-from-below']
      },
      {
        description: "A function with an undefined point",
        expectedBehaviors: ['inc-linear', 'v-asym-left-up']
      },
      {
        description: "A horizontal line that suddenly drops and continues falling",
        expectedBehaviors: ['const', 'jump-down-right', 'dec-linear']
      },
      {
        description: "A function that smoothly transitions between opposite curvatures",
        expectedBehaviors: ['dec-cdown', 'inflect-down-up', 'inc-cup']
      }
    ];

    // Generate new Build challenge
    function generateNewBuildChallenge() {
      state.buildChallenge = buildChallenges[Math.floor(Math.random() * buildChallenges.length)];
      document.getElementById('build-challenge').textContent = state.buildChallenge.description;
      clearBuildSequence();
    }

    // Initialize and update Build graph
    function initializeBuildGraph() {
      const canvas = document.getElementById('build-graph');
      if (!canvas) return;
      
      canvas.width = canvas.offsetWidth || 800;
      canvas.height = 350;
      
      const ctx = canvas.getContext('2d');
      drawGrid(ctx, canvas.width, canvas.height);
    }

    function updateBuildGraph() {
      const canvas = document.getElementById('build-graph');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      drawGrid(ctx, w, h);
      
      if (state.buildSequence.length === 0) return;
      
      // Draw the composed function based on selected behaviors
      ctx.save();
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      
      // Map behavior IDs to drawing logic
      let x = 80;
      let currentY = h * 0.5;
      const segmentWidth = (w - 160) / Math.max(state.buildSequence.length, 1);
      
      state.buildSequence.forEach((behaviorId, i) => {
        const startX = x;
        const endX = x + segmentWidth;
        
        // Draw based on behavior ID
        // This is simplified - you'd implement full drawing logic for each behavior type
        ctx.beginPath();
        ctx.moveTo(startX, currentY);
        
        if (behaviorId.includes('inc')) {
          currentY -= 40;
          if (behaviorId.includes('cup')) {
            ctx.quadraticCurveTo((startX + endX)/2, currentY + 20, endX, currentY);
          } else if (behaviorId.includes('cdown')) {
            ctx.quadraticCurveTo((startX + endX)/2, currentY - 20, endX, currentY);
          } else {
            ctx.lineTo(endX, currentY);
          }
        } else if (behaviorId.includes('dec')) {
          currentY += 40;
          if (behaviorId.includes('cup')) {
            ctx.quadraticCurveTo((startX + endX)/2, currentY + 20, endX, currentY);
          } else if (behaviorId.includes('cdown')) {
            ctx.quadraticCurveTo((startX + endX)/2, currentY - 20, endX, currentY);
          } else {
            ctx.lineTo(endX, currentY);
          }
        } else if (behaviorId === 'const') {
          ctx.lineTo(endX, currentY);
        }
        // Add more behavior handling...
        
        ctx.stroke();
        x = endX;
      });
      
      ctx.restore();
    }

    // Animate function construction
    function animateFunction() {
      const canvas = document.getElementById('build-graph');
      if (canvas) {
        canvas.style.opacity = '0';
        updateBuildGraph();
        setTimeout(() => {
          canvas.style.transition = 'opacity 1s ease';
          canvas.style.opacity = '1';
        }, 100);
      }
    }

    // AI Integration
    async function callAI(prompt) {
      try {
        const response = await fetch('/api/gemini', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            contents: [{ 
              role: "user", 
              parts: [{ text: prompt }] 
            }] 
          })
        });
        
        if (!response.ok) return null;
        
        const data = await response.json();
        return data.candidates?.[0]?.content?.parts?.[0]?.text;
      } catch (error) {
        console.error('AI Error:', error);
        return null;
      }
    }

    async function checkBuildAnswer() {
      const feedback = document.getElementById('build-feedback');
      
      if (state.buildSequence.length === 0) {
        feedback.className = 'feedback error show';
        feedback.textContent = 'Please add image cards first.';
        return;
      }
      
      const prompt = `Challenge: "${state.buildChallenge.description}"
Student built: ${state.buildSequence.join(' → ')}

Evaluate if their visual construction matches the description. Don't give away the answer.
Respond with ONE of:
- "Correct!" if it matches
- "Not quite. Check your [first/middle/last] card." if wrong
- "Close! Adjust the [specific aspect]" if partially correct

Keep response under 15 words. Don't reveal the solution.`;

      feedback.className = 'feedback info show';
      feedback.textContent = 'Checking...';
      
      const aiResponse = await callAI(prompt);
      
      if (aiResponse) {
        if (aiResponse.toLowerCase().includes('correct')) {
          feedback.className = 'feedback success show';
        } else if (aiResponse.toLowerCase().includes('close')) {
          feedback.className = 'feedback info show';
        } else {
          feedback.className = 'feedback error show';
        }
        feedback.textContent = aiResponse;
      } else {
        feedback.className = 'feedback info show';
        feedback.textContent = 'AI unavailable. Review your sequence.';
      }
    }

    // Tab management
    function switchToTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tab === tabName) {
          btn.classList.add('active');
        }
      });
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      document.getElementById(tabName).classList.add('active');
      
      if (tabName === 'intro') {
        setTimeout(drawExamples, 50);
      } else if (tabName === 'read') {
        initializeReadTab();
      } else if (tabName === 'build') {
        initializeBuildTab();
      }
    }

    function setupTabs() {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchToTab(btn.dataset.tab);
        });
      });
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      setupTabs();
      drawExamples();
    });
  </script>
</body>
</html>
      
      
