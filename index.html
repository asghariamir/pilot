<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Function Analyzer | Mathswell</title>
    <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
    <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    
    <style>
        /* Mathswell Color System */
        :root {
            --primary: #0f766e;
            --primary-light: #10b981;
            --background: #f7faf9;
            --interactive: #e6fffb;
            --text-primary: #212121;
            --text-muted: #4b5563;
            --accent-amber: #f59e0b;
            --accent-red: #dc2626;
            --success: #10b981;
            --surface: #ffffff;
            --border: #e5e7eb;
            --blue: #1e40af;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: var(--background);
            color: var(--text-primary);
            line-height: 1.6;
        }
        
        /* Mathswell Navigation */
        .mathswell-nav {
            display: flex;
            justify-content: center;
            margin: 1rem 0 1.5rem;
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .mw-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            font-weight: 700;
            font-size: 1rem;
            color: var(--primary);
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.2s ease;
        }
        
        .mw-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.12);
        }
        
        /* Container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            background: var(--surface);
            border-radius: 12px;
            box-shadow: 0 4px 16px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 0.5rem;
            font-size: 2rem;
        }
        
        .subtitle {
            text-align: center;
            color: var(--text-muted);
            margin-bottom: 2rem;
        }
        
        /* Tabs - Centered */
        .tabs {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0;
        }
        
        .tab-btn {
            padding: 0.75rem 2rem;
            border: none;
            background: transparent;
            color: var(--text-muted);
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.2s ease;
        }
        
        .tab-btn:hover {
            color: var(--primary);
            background: var(--interactive);
        }
        
        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: var(--interactive);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Introduction Tab */
        .hero-section {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(135deg, var(--interactive) 0%, rgba(230,255,251,0.3) 100%);
            border-radius: 12px;
            margin-bottom: 2rem;
        }
        
        .concept-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .concept-card {
            background: var(--surface);
            border: 2px solid var(--primary);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.2s ease;
        }
        
        .concept-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.1);
        }
        
        .concept-card h3 {
            color: var(--primary);
            margin-bottom: 0.75rem;
            font-size: 1.2rem;
        }
        
        .demo-area {
            background: var(--surface);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        .demo-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        
        .demo-btn {
            padding: 0.75rem 2rem;
            border-radius: 999px;
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            font-size: 1rem;
        }
        
        .demo-btn:hover {
            background: var(--interactive);
            transform: translateY(-2px);
        }
        
        .demo-btn.active {
            background: var(--primary);
            color: white;
        }
        
        /* Canvas */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .canvas-wrapper::before {
            content: '';
            display: block;
            padding-top: 100%;
        }
        
        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            border-radius: 10px;
        }
        
        #intro-canvas, #grid-canvas {
            border: 1.5px solid var(--border);
            z-index: 1;
        }
        
        #main-canvas {
            z-index: 2;
            cursor: crosshair;
        }
        
        #handle-canvas {
            z-index: 3;
        }
        
        /* Control Boxes */
        .control-row {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .control-box {
            background: var(--interactive);
            border-radius: 8px;
            padding: 1.25rem;
        }
        
        .control-box h4 {
            color: var(--primary);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }
        
        /* Interval Selector */
        .interval-selector {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.5rem;
            background: white;
            border: 2px solid var(--primary);
            border-radius: 8px;
            font-family: 'Monaco', 'Courier New', monospace;
            font-size: 1rem;
        }
        
        .interval-bracket {
            font-size: 1.6rem;
            color: var(--primary);
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            padding: 0 0.3rem;
            transition: all 0.2s ease;
            font-family: 'Courier New', monospace;
            min-width: 20px;
            text-align: center;
            display: inline-block;
        }
        
        .interval-bracket:hover {
            transform: scale(1.3);
            color: var(--accent-amber);
            background: var(--interactive);
            border-radius: 4px;
        }
        
        .interval-input {
            width: 60px;
            padding: 0.2rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            text-align: center;
            font-family: inherit;
            font-size: 0.9rem;
        }
        
        /* Buttons */
        .btn {
            padding: 0.75rem 1.25rem;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-secondary {
            background: var(--primary-light);
            color: white;
        }
        
        .btn-danger {
            background: var(--accent-red);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            filter: brightness(1.1);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Table */
        .table-container {
            max-height: 250px;
            overflow-y: auto;
            border-radius: 8px;
            border: 1px solid var(--border);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
            background: white;
        }
        
        th {
            background: var(--interactive);
            color: var(--primary);
            padding: 0.5rem 0.3rem;
            text-align: center;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        td {
            padding: 0.4rem 0.3rem;
            border-bottom: 1px solid var(--border);
            text-align: center;
        }
        
        tr.selected-row {
            background: var(--interactive);
        }
        
        .drag-handle {
            cursor: grab;
            font-size: 1.1em;
            color: var(--text-muted);
            user-select: none;
        }
        
        /* Form Elements */
        select, input[type="number"], input[type="text"] {
            padding: 0.2rem 0.3rem;
            border: 1px solid var(--border);
            border-radius: 4px;
            font-size: 0.85rem;
            width: 100%;
        }
        
        .input-pair {
            display: flex;
            gap: 0.2rem;
        }
        
        /* Analysis Results */
        .analysis-results {
            background: var(--interactive);
            border: 2px solid var(--primary);
            border-radius: 8px;
            padding: 1rem;
            font-family: ui-monospace, 'Monaco', monospace;
            font-size: 0.85rem;
            line-height: 1.8;
            min-height: 150px;
        }
        
        .analysis-results strong {
            color: var(--primary);
        }
        
        /* Challenge Section */
        .challenge-section {
            background: linear-gradient(135deg, #fff9f0 0%, #ffe8d6 100%);
            border: 2px solid var(--accent-amber);
            border-radius: 12px;
            padding: 1.5rem;
            margin-top: 2rem;
        }
        
        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .challenge-header h4 {
            color: var(--accent-amber);
            font-size: 1.2rem;
            margin: 0;
        }
        
        .challenge-content {
            background: white;
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 1rem;
            line-height: 1.8;
        }
        
        .challenge-requirement {
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
        }
        
        .challenge-requirement:last-child {
            border-bottom: none;
        }
        
        .feedback-box {
            background: var(--interactive);
            border-left: 4px solid var(--primary);
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: none;
        }
        
        .feedback-box.show {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        .feedback-box.success {
            border-left-color: var(--success);
            background: #d1fae5;
        }
        
        .feedback-box.warning {
            border-left-color: var(--accent-amber);
            background: #fed7aa;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-10px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .info-display {
            background: var(--interactive);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'Monaco', monospace;
            margin-top: 1rem;
        }
        
        .violation-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--accent-red);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-weight: bold;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .ai-disclaimer {
            margin-top: 1rem;
            padding: 0.75rem;
            background: #f3f4f6;
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.85rem;
            text-align: center;
            line-height: 1.4;
        }
        
        /* Mobile */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                border-radius: 0;
            }
            
            h1 {
                font-size: 1.5rem;
            }
            
            .demo-controls {
                flex-direction: column;
            }
            
            .control-row {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Mathswell Navigation Badge -->
    <div class="mathswell-nav">
        <a href="/" class="mw-link">
            <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
            <span>MATHSWELL</span>
        </a>
    </div>
    
    <div class="container">
        <h1>📈 Function Analyzer</h1>
        <p class="subtitle">Build, test, and analyze mathematical functions interactively</p>
        
        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-tab="intro">Learn</button>
            <button class="tab-btn" data-tab="explorer">Build & Challenge</button>
        </div>
        
        <!-- Introduction Tab -->
        <div id="intro" class="tab-content active">
            <div class="hero-section">
                <h2>What Makes a Function?</h2>
                <p>A function is a special relationship where each input (x-value) has exactly one output (y-value). The vertical line test helps us check this!</p>
            </div>
            
            <div class="concept-cards">
                <div class="concept-card">
                    <h3>📊 The Vertical Line Test</h3>
                    <p>If any vertical line crosses a graph more than once, it's not a function.</p>
                    <div class="info-display">
                        <strong>Key Rule:</strong> One input → One output
                    </div>
                </div>
                
                <div class="concept-card">
                    <h3>🎯 Domain & Range</h3>
                    <p><strong>Domain:</strong> All possible x-values<br>
                    <strong>Range:</strong> All possible y-values</p>
                    <div class="info-display">
                        Example: f(x) = x²<br>
                        Domain: (-∞, ∞)<br>
                        Range: [0, ∞)
                    </div>
                </div>
                
                <div class="concept-card">
                    <h3>📈 Function Behavior</h3>
                    <p>• <strong>Increasing:</strong> Going up ↗<br>
                    • <strong>Decreasing:</strong> Going down ↘<br>
                    • <strong>Constant:</strong> Staying flat →<br>
                    • <strong>Concave Up:</strong> Holds water ∪<br>
                    • <strong>Concave Down:</strong> Sheds water ∩</p>
                </div>
            </div>
            
            <div class="demo-area">
                <h3>Interactive Demo: Test Different Graphs!</h3>
                <div class="demo-controls">
                    <button class="demo-btn active" onclick="switchDemoType('function')">✅ Functions</button>
                    <button class="demo-btn" onclick="switchDemoType('not-function')">❌ Not Functions</button>
                    <button class="btn btn-secondary" onclick="nextDemoExample()">Next Example →</button>
                </div>
                
                <div class="canvas-wrapper" style="position: relative;">
                    <canvas id="intro-canvas"></canvas>
                    <div id="violation-indicator" class="violation-indicator" style="display: none;">
                        ❌ Multiple y-values!
                    </div>
                </div>
                
                <div id="intro-result" class="info-display" style="text-align: center;">
                    <span id="demo-name" style="font-weight: bold;">Loading...</span><br>
                    <span id="demo-description">Loading...</span>
                </div>
            </div>
        </div>
        
        <!-- Explorer & Challenge Tab - NEW VERTICAL LAYOUT -->
        <div id="explorer" class="tab-content">
            <!-- 1. Build Controls at Top -->
            <div class="control-box" style="margin-bottom: 1rem;">
                <h4>🛠️ Build Controls</h4>
                <div class="control-row">
                    <button id="add-segment" class="btn btn-primary">Add Segment</button>
                    <button id="undo-btn" class="btn btn-secondary">↶ Undo</button>
                    <button id="clear-all" class="btn btn-danger">Clear All</button>
                </div>
            </div>
            
            <!-- 2. Segments Table -->
            <div class="control-box" style="margin-bottom: 1.5rem;">
                <h4>📝 Segments</h4>
                <div class="table-container">
                    <table id="segment-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Type</th>
                                <th>Domain</th>
                                <th>Y-Values</th>
                                <th>Curve</th>
                                <th>Del</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
            
            <!-- 3. Canvas for Graph -->
            <div class="canvas-wrapper" style="max-width: 500px; margin: 0 auto 1.5rem;">
                <canvas id="grid-canvas"></canvas>
                <canvas id="main-canvas"></canvas>
                <canvas id="handle-canvas"></canvas>
            </div>
            
            <!-- 4. Live Analysis -->
            <div class="control-box" style="margin-bottom: 1.5rem;">
                <h4>🔍 Live Analysis</h4>
                <div id="analysis-results" class="analysis-results">
                    Add segments to begin analysis.
                </div>
            </div>
            
            <!-- 5. Function Challenge Section -->
            <div class="challenge-section">
                <div class="challenge-header">
                    <h4>🎯 Function Challenge</h4>
                    <span id="challenge-badge" style="background: var(--accent-amber); color: white; padding: 0.25rem 0.75rem; border-radius: 999px; font-weight: 600;">
                        Challenge #1
                    </span>
                </div>
                
                <div class="challenge-content">
                    <strong>Build a function with these properties:</strong>
                    <div id="requirements" style="margin-top: 0.5rem;">
                        Loading challenge...
                    </div>
                </div>
                
                <div class="control-row">
                    <button id="check-challenge" class="btn btn-primary">Check My Function</button>
                    <button id="get-hint" class="btn btn-secondary">Get Hint</button>
                    <button id="new-challenge" class="btn btn-secondary">New Challenge</button>
                </div>
                
                <div id="challenge-feedback" class="feedback-box"></div>
                
                <div class="ai-disclaimer">
                    💡 AI feedback simulated locally for educational purposes. 
                    Results may vary. Always verify mathematical concepts with multiple sources.
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // State Management
        const DPR = window.devicePixelRatio || 1;
        const WMIN = -8, WMAX = 8, GRID = 1;
        
        const state = {
            segments: [],
            sel: null,
            undo: [],
            drag: { 
                handle: false, 
                curveIdx: null,
                endpointIdx: null,
                endpointType: null // 'p1', 'p2', or 'handle'
            },
            demoType: 'function',
            demoIndex: 0,
            vlineAnimation: null,
            vlineX: WMIN,
            demoVlineX: WMIN,
            demoVlineAnimation: null,
            demoVlinePaused: false,
            currentChallenge: null,
            attempts: 0,
            showHandles: true,
            challengeNumber: 0  // Track challenge number starting from 0
        };
        
        // Demo Examples - More Mathematically Representative
        const demoExamples = {
            'function': [
                {
                    name: 'Linear Function',
                    description: '✅ A straight line passes the vertical line test!',
                    draw: (ctx, size) => {
                        for (let x = -7; x <= 7; x += 0.1) {
                            const y = 0.5 * x + 1;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -7) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Step Function',
                    description: '✅ Jump discontinuities are allowed in functions!',
                    draw: (ctx, size) => {
                        // First step
                        ctx.beginPath();
                        for (let x = -7; x <= -3; x += 0.01) {
                            const y = -3;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -7) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                        ctx.stroke();
                        
                        // Open circle at end of first step
                        ctx.beginPath();
                        ctx.arc(size * (((-3) + 8) / 16), size * ((8 - (-3)) / 16), 4, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Second step with closed start
                        ctx.beginPath();
                        ctx.arc(size * (((-3) + 8) / 16), size * ((8 - 0) / 16), 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.beginPath();
                        for (let x = -3; x <= 1; x += 0.01) {
                            const y = 0;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -3) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                        ctx.stroke();
                        
                        // Open circle at end of second step
                        ctx.beginPath();
                        ctx.arc(size * ((1 + 8) / 16), size * ((8 - 0) / 16), 4, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Third step with closed start
                        ctx.beginPath();
                        ctx.arc(size * ((1 + 8) / 16), size * ((8 - 3) / 16), 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.stroke();
                        
                        ctx.beginPath();
                        for (let x = 1; x <= 6; x += 0.01) {
                            const y = 3;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === 1) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                        ctx.stroke();
                    }
                },
                {
                    name: 'Parabola',
                    description: '✅ Each x-value has exactly one y-value.',
                    draw: (ctx, size) => {
                        for (let x = -7; x <= 7; x += 0.1) {
                            const y = 0.2 * (x * x) - 5;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (y >= -8 && y <= 8) {
                                if (x === -7) ctx.moveTo(screenX, screenY);
                                else ctx.lineTo(screenX, screenY);
                            }
                        }
                    }
                },
                {
                    name: 'Sine Wave',
                    description: '✅ Trigonometric functions are functions!',
                    draw: (ctx, size) => {
                        for (let x = -8; x <= 8; x += 0.1) {
                            const y = 3 * Math.sin(x * 0.8);
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === -8) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Exponential (e^x)',
                    description: '✅ Exponential functions approach zero and grow rapidly!',
                    draw: (ctx, size) => {
                        let started = false;
                        for (let x = -8; x <= 2.2; x += 0.05) {
                            const y = Math.exp(x); // Pure e^x
                            if (y >= -0.5 && y <= 8) {
                                const screenX = size * ((x + 8) / 16);
                                const screenY = size * ((8 - y) / 16);
                                if (!started) {
                                    ctx.moveTo(screenX, screenY);
                                    started = true;
                                } else {
                                    ctx.lineTo(screenX, screenY);
                                }
                            }
                        }
                    }
                },
                {
                    name: 'Square Root (√x)',
                    description: '✅ Square root function has a restricted domain!',
                    draw: (ctx, size) => {
                        for (let x = 0; x <= 8; x += 0.05) {
                            const y = 2 * Math.sqrt(x); // Scale by 2 for visibility
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (x === 0) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    }
                },
                {
                    name: 'Rational Function',
                    description: '✅ Has a vertical asymptote but still a function!',
                    draw: (ctx, size) => {
                        // Left branch
                        ctx.beginPath();
                        for (let x = -7.5; x <= -0.2; x += 0.1) {
                            const y = 3 / (x + 0.0001);
                            if (y >= -7.5 && y <= 7.5) {
                                const screenX = size * ((x + 8) / 16);
                                const screenY = size * ((8 - y) / 16);
                                if (x === -7.5) ctx.moveTo(screenX, screenY);
                                else ctx.lineTo(screenX, screenY);
                            }
                        }
                        ctx.stroke();
                        
                        // Right branch
                        ctx.beginPath();
                        for (let x = 0.2; x <= 7.5; x += 0.1) {
                            const y = 3 / x;
                            if (y >= -7.5 && y <= 7.5) {
                                const screenX = size * ((x + 8) / 16);
                                const screenY = size * ((8 - y) / 16);
                                if (x === 0.2) ctx.moveTo(screenX, screenY);
                                else ctx.lineTo(screenX, screenY);
                            }
                        }
                    }
                }
            ],
            'not-function': [
                {
                    name: 'Circle',
                    description: '❌ Most x-values have TWO y-values!',
                    draw: (ctx, size) => {
                        ctx.arc(size / 2, size / 2, size * 0.3, 0, Math.PI * 2);
                    },
                    violationX: 0 // Where to show violation
                },
                {
                    name: 'Sideways Parabola',
                    description: '❌ The vertical line crosses it multiple times!',
                    draw: (ctx, size) => {
                        for (let y = -6; y <= 6; y += 0.1) {
                            const x = 0.25 * y * y - 3;
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (y === -6) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    },
                    violationX: 3
                },
                {
                    name: 'Figure Eight',
                    description: '❌ It crosses itself in the middle!',
                    draw: (ctx, size) => {
                        for (let t = 0; t <= Math.PI * 2; t += 0.05) {
                            const x = 4 * Math.sin(t);
                            const y = 4 * Math.sin(2 * t);
                            const screenX = size * ((x + 8) / 16);
                            const screenY = size * ((8 - y) / 16);
                            if (t === 0) ctx.moveTo(screenX, screenY);
                            else ctx.lineTo(screenX, screenY);
                        }
                    },
                    violationX: 0
                },
                {
                    name: 'Vertical Line',
                    description: '❌ One x has INFINITE y-values!',
                    draw: (ctx, size) => {
                        const x = 2;
                        const screenX = size * ((x + 8) / 16);
                        ctx.moveTo(screenX, size * 0.05);
                        ctx.lineTo(screenX, size * 0.95);
                    },
                    violationX: 2
                },
                {
                    name: 'Ellipse',
                    description: '❌ An oval shape fails the vertical line test!',
                    draw: (ctx, size) => {
                        ctx.save();
                        ctx.translate(size / 2, size / 2);
                        ctx.scale(1.5, 1);
                        ctx.arc(0, 0, size * 0.25, 0, Math.PI * 2);
                        ctx.restore();
                    },
                    violationX: 0
                }
            ]
        };
        
        // Tab Switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.tab === tabName) {
                    btn.classList.add('active');
                }
            });
            
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'explorer') {
                setTimeout(() => resize(), 100);
            }
        }
        
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
        
        // Demo Functions
        function switchDemoType(type) {
            state.demoType = type;
            state.demoIndex = 0;
            state.demoVlinePaused = false;
            
            document.querySelectorAll('.demo-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.textContent.includes(type === 'function' ? 'Functions' : 'Not Functions')) {
                    btn.classList.add('active');
                }
            });
            
            // Start/stop vertical line animation based on type
            if (type === 'not-function') {
                startDemoVlineAnimation();
            } else {
                stopDemoVlineAnimation();
            }
            
            drawDemoExample();
        }
        
        function nextDemoExample() {
            const examples = demoExamples[state.demoType];
            state.demoIndex = (state.demoIndex + 1) % examples.length;
            state.demoVlinePaused = false;
            document.getElementById('violation-indicator').style.display = 'none';
            drawDemoExample();
        }
        
        function startDemoVlineAnimation() {
            if (state.demoVlineAnimation) return;
            state.demoVlineX = WMIN;
            state.demoVlinePaused = false;
            
            state.demoVlineAnimation = setInterval(() => {
                if (!state.demoVlinePaused) {
                    state.demoVlineX += 0.15;
                    if (state.demoVlineX > WMAX) {
                        state.demoVlineX = WMIN;
                        state.demoVlinePaused = false;
                        document.getElementById('violation-indicator').style.display = 'none';
                    }
                    
                    // Check if we're at a violation point
                    const example = demoExamples[state.demoType][state.demoIndex];
                    if (example.violationX !== undefined) {
                        const diff = Math.abs(state.demoVlineX - example.violationX);
                        if (diff < 0.3) {
                            state.demoVlinePaused = true;
                            document.getElementById('violation-indicator').style.display = 'block';
                            setTimeout(() => {
                                state.demoVlinePaused = false;
                                document.getElementById('violation-indicator').style.display = 'none';
                            }, 2000);
                        }
                    }
                }
                drawDemoExample();
            }, 50);
        }
        
        function stopDemoVlineAnimation() {
            if (state.demoVlineAnimation) {
                clearInterval(state.demoVlineAnimation);
                state.demoVlineAnimation = null;
                state.demoVlineX = WMIN;
                state.demoVlinePaused = false;
                document.getElementById('violation-indicator').style.display = 'none';
                drawDemoExample();
            }
        }
        
        function drawDemoExample() {
            const canvas = document.getElementById('intro-canvas');
            const ctx = canvas.getContext('2d');
            const size = canvas.parentElement.getBoundingClientRect().width;
            
            canvas.width = size * DPR;
            canvas.height = size * DPR;
            ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
            
            ctx.clearRect(0, 0, size, size);
            
            // Draw grid
            drawIntroGrid(ctx, size);
            
            // Get current example
            const example = demoExamples[state.demoType][state.demoIndex];
            
            // Draw the graph
            ctx.strokeStyle = '#0f766e';
            ctx.lineWidth = 3;
            ctx.fillStyle = '#0f766e';
            ctx.beginPath();
            example.draw(ctx, size);
            ctx.stroke();
            
            // Draw animated vertical test line for non-functions
            if (state.demoType === 'not-function') {
                const screenX = size * ((state.demoVlineX + 8) / 16);
                ctx.strokeStyle = state.demoVlinePaused ? '#dc2626' : '#f59e0b';
                ctx.lineWidth = state.demoVlinePaused ? 3 : 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(screenX, 0);
                ctx.lineTo(screenX, size);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Update description
            document.getElementById('demo-name').textContent = example.name;
            document.getElementById('demo-description').textContent = example.description;
        }
        
        function drawIntroGrid(ctx, size) {
            ctx.strokeStyle = '#e5e7eb';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 16; i++) {
                const pos = (i / 16) * size;
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
        }
        
        // Explorer Tab Functions
        const gridCv = document.getElementById('grid-canvas');
        const mainCv = document.getElementById('main-canvas');
        const handleCv = document.getElementById('handle-canvas');
        const gCtx = gridCv.getContext('2d');
        const mCtx = mainCv.getContext('2d');
        const hCtx = handleCv.getContext('2d');
        
        const cssSize = cv => ({ w: cv.getBoundingClientRect().width, h: cv.getBoundingClientRect().height });
        const toScreen = (p, cvSize) => ({ x: (p.x - WMIN) / (WMAX - WMIN) * cvSize.w, y: (WMAX - p.y) / (WMAX - WMIN) * cvSize.h });
        const fromScreen = (c, cvSize) => ({ x: WMIN + c.x / cvSize.w * (WMAX - WMIN), y: WMAX - c.y / cvSize.h * (WMAX - WMIN) });
        const deep = obj => JSON.parse(JSON.stringify(obj));
        
        // Initialize
        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('resize', resize);
        
        function init() {
            attachListeners();
            resize();
            pushUndo();
            
            // Add initial example segments with slope handles
            state.segments.push({ 
                type: 'line', 
                p1: { x: -6, y: 2 }, 
                p2: { x: -1, y: 2 }, 
                startType: 'closed', 
                endType: 'open', 
                handle: { x: -3.5, y: 4 },
                slopeHandle1: { x: -5, y: 2 },  // New: slope control handle for p1
                slopeHandle2: { x: -2, y: 2 }   // New: slope control handle for p2
            });
            state.segments.push({ 
                type: 'curve', 
                p1: { x: -1, y: 3 }, 
                p2: { x: 4, y: -2 }, 
                startType: 'closed', 
                endType: 'closed', 
                handle: { x: 1, y: 5 },
                slopeHandle1: { x: 0, y: 4 },
                slopeHandle2: { x: 3, y: -3 }
            });
            state.sel = 1;
            refresh();
            
            // Load first demo with parabola (index 2)
            state.demoIndex = 2;  // Start with parabola
            drawDemoExample();
            
            // Generate first challenge (will be Challenge #1)
            generateNewChallenge();
        }
        
        function resize() {
            const boxes = [gridCv, mainCv, handleCv];
            boxes.forEach(cv => {
                if (!cv) return;
                const box = cv.parentElement?.getBoundingClientRect();
                if (!box) return;
                const size = box.width;
                cv.style.width = `${size}px`; 
                cv.style.height = `${size}px`;
                cv.width = size * DPR; 
                cv.height = size * DPR;
                cv.getContext('2d').setTransform(DPR, 0, 0, DPR, 0, 0);
            });
            drawAll();
        }
        
        function attachListeners() {
            document.getElementById('add-segment').addEventListener('click', addSegment);
            document.getElementById('undo-btn').addEventListener('click', undo);
            document.getElementById('clear-all').addEventListener('click', clearAll);
            document.querySelector('#segment-table tbody').addEventListener('input', onCellEdit);
            document.querySelector('#segment-table tbody').addEventListener('click', onTableClick);
            
            // Canvas mouse events
            handleCv.addEventListener('mousedown', canvasDown);
            handleCv.addEventListener('mousemove', canvasMove);
            document.addEventListener('mouseup', canvasUp);
            handleCv.addEventListener('mouseleave', () => handleCv.style.cursor = 'default');
            
            // Challenge listeners
            document.getElementById('check-challenge').addEventListener('click', checkChallenge);
            document.getElementById('get-hint').addEventListener('click', getHint);
            document.getElementById('new-challenge').addEventListener('click', generateNewChallenge);
        }
        
        function refresh() {
            renderTable();
            drawAll();
            runAnalysis();
            document.getElementById('undo-btn').disabled = state.undo.length === 0;
        }
        
        function clearAll() {
            pushUndo();
            state.segments = [];
            state.sel = null;
            refresh();
        }
        
        function addSegment() {
            pushUndo();
            const last = state.segments[state.segments.length - 1];
            const start = last ? deep(last.p2) : { x: -2, y: 1 };
            const end = { x: start.x + 3, y: start.y + 1 };
            state.segments.push({
                type: "line",
                p1: start,
                p2: end,
                startType: "closed",
                endType: "closed",
                handle: { x: start.x + 1.5, y: start.y + 2 },
                slopeHandle1: { x: start.x + 1, y: start.y + 0.5 },
                slopeHandle2: { x: end.x - 1, y: end.y - 0.5 }
            });
            state.sel = state.segments.length - 1;
            refresh();
        }
        
        function renderTable() {
            const tbody = document.querySelector("#segment-table tbody");
            tbody.innerHTML = "";
            
            state.segments.forEach((seg, i) => {
                const row = document.createElement("tr");
                row.className = i === state.sel ? "selected-row" : "";
                
                row.addEventListener("click", e => {
                    if (e.target.tagName !== "INPUT" && e.target.tagName !== "SELECT" && 
                        e.target.tagName !== "BUTTON" && !e.target.classList.contains('interval-bracket')) {
                        state.sel = i;
                        refresh();
                    }
                });
                
                const td = html => {
                    const cell = document.createElement("td");
                    cell.innerHTML = html;
                    return cell;
                };
                
                row.appendChild(td('<div class="drag-handle">☰</div>'));
                row.appendChild(td(`<select data-i="${i}" data-k="type">
                    <option value="line" ${seg.type === "line" ? "selected" : ""}>Line</option>
                    <option value="curve" ${seg.type === "curve" ? "selected" : ""}>Curve</option>
                </select>`));
                
                // Domain interval selector
                const domainCell = document.createElement("td");
                domainCell.innerHTML = `
                    <div class="interval-selector">
                        <span class="interval-bracket" data-i="${i}" data-k="startType">
                            ${seg.startType === '-infty' ? '(' : seg.startType === 'open' ? '(' : '['}
                        </span>
                        ${seg.startType === '-infty' ? 
                            `<span style="font-size: 0.9rem;">-∞</span>` :
                            `<input type="text" class="interval-input" value="${seg.p1.x}" 
                                   data-i="${i}" data-k="p1.x">`
                        }
                        <span>,</span>
                        ${seg.endType === '+infty' ? 
                            `<span style="font-size: 0.9rem;">+∞</span>` :
                            `<input type="text" class="interval-input" value="${seg.p2.x}" 
                                   data-i="${i}" data-k="p2.x">`
                        }
                        <span class="interval-bracket" data-i="${i}" data-k="endType">
                            ${seg.endType === '+infty' ? ')' : seg.endType === 'open' ? ')' : ']'}
                        </span>
                    </div>
                `;
                
                domainCell.querySelectorAll('.interval-bracket').forEach(bracket => {
                    bracket.addEventListener('click', e => {
                        e.stopPropagation();
                        const key = e.target.dataset.k;
                        const currentType = seg[key];
                        let newType;
                        
                        if (key === 'startType') {
                            // Cycle: closed -> open -> -infty -> closed
                            if (currentType === 'closed') newType = 'open';
                            else if (currentType === 'open') newType = '-infty';
                            else newType = 'closed';
                        } else {
                            // Cycle: closed -> open -> +infty -> closed
                            if (currentType === 'closed') newType = 'open';
                            else if (currentType === 'open') newType = '+infty';
                            else newType = 'closed';
                        }
                        
                        pushUndo();
                        seg[key] = newType;
                        refresh();
                    });
                });
                
                row.appendChild(domainCell);
                
                // Y-values
                row.appendChild(td(`
                    <div class="input-pair">
                        <input type="text" value="${seg.p1.y}" data-i="${i}" data-k="p1.y" 
                               style="width: 50px;">
                        <input type="text" value="${seg.p2.y}" data-i="${i}" data-k="p2.y" 
                               style="width: 50px;">
                    </div>
                `));
                
                // Curve controls
                row.appendChild(td(seg.type === 'curve' ? 
                    `<input type="checkbox" ${state.showHandles ? 'checked' : ''} 
                            onchange="state.showHandles = this.checked; drawAll()">` 
                    : '-'
                ));
                
                row.appendChild(td(`<button class="btn btn-danger" style="padding: 0.2rem 0.4rem; font-size: 0.8rem;" 
                                           data-act="del" data-i="${i}">✕</button>`));
                tbody.appendChild(row);
            });
        }
        
        function setVal(obj, path, val) {
            const keys = path.split(".");
            let current = obj;
            for (let i = 0; i < keys.length - 1; i++) {
                current = current[keys[i]];
            }
            current[keys[keys.length - 1]] = val;
        }
        
        function onCellEdit(e) {
            const el = e.target;
            if (!el.dataset.k) return;
            
            const i = +el.dataset.i;
            const seg = state.segments[i];
            
            // Handle type change to ensure slope handles exist
            if (el.dataset.k === "type") {
                pushUndo();
                seg.type = el.value;
                // Initialize slope handles if changing to line and they don't exist
                if (seg.type === 'line' && (!seg.slopeHandle1 || !seg.slopeHandle2)) {
                    seg.slopeHandle1 = { 
                        x: seg.p1.x + (seg.p2.x - seg.p1.x) * 0.3, 
                        y: seg.p1.y + (seg.p2.y - seg.p1.y) * 0.3 + 1 
                    };
                    seg.slopeHandle2 = { 
                        x: seg.p1.x + (seg.p2.x - seg.p1.x) * 0.7, 
                        y: seg.p1.y + (seg.p2.y - seg.p1.y) * 0.7 - 1 
                    };
                }
                refresh();
                return;
            }
            
            // For text inputs, allow negative numbers properly
            if (el.tagName === "INPUT") {
                const value = el.value.trim();
                // Allow empty or just minus sign while typing
                if (value === '' || value === '-') {
                    return; // Don't update yet, let user continue typing
                }
                const parsed = parseFloat(value);
                if (!isNaN(parsed)) {
                    pushUndo();
                    setVal(seg, el.dataset.k, parsed);
                    refresh();
                }
            } else {
                pushUndo();
                setVal(seg, el.dataset.k, el.value);
                refresh();
            }
        }
        
        function onTableClick(e) {
            const btn = e.target.closest('button[data-act]');
            if (!btn) return;
            const i = +btn.dataset.i;
            if (btn.dataset.act === "del") {
                pushUndo();
                state.segments.splice(i, 1);
                state.sel = state.segments.length > 0 ? Math.max(0, i - 1) : null;
                refresh();
            }
        }
        
        function pushUndo() {
            state.undo.push(deep({ seg: state.segments, sel: state.sel }));
            document.getElementById('undo-btn').disabled = false;
        }
        
        function undo() {
            if (state.undo.length === 0) return;
            const prev = state.undo.pop();
            state.segments = prev.seg;
            state.sel = prev.sel;
            refresh();
        }
        
        // Drawing functions
        function drawGrid() {
            const size = cssSize(gridCv);
            gCtx.clearRect(0, 0, size.w, size.h);
            gCtx.strokeStyle = "#e5e7eb";
            gCtx.lineWidth = 1;
            
            for (let x = Math.ceil(WMIN); x <= Math.floor(WMAX); x += GRID) {
                const screen = toScreen({ x: x, y: 0 }, size);
                gCtx.beginPath();
                gCtx.moveTo(screen.x, 0);
                gCtx.lineTo(screen.x, size.h);
                gCtx.stroke();
            }
            
            for (let y = Math.ceil(WMIN); y <= Math.floor(WMAX); y += GRID) {
                const screen = toScreen({ x: 0, y: y }, size);
                gCtx.beginPath();
                gCtx.moveTo(0, screen.y);
                gCtx.lineTo(size.w, screen.y);
                gCtx.stroke();
            }
            
            const origin = toScreen({ x: 0, y: 0 }, size);
            gCtx.lineWidth = 1.5;
            gCtx.strokeStyle = "#94a3b8";
            gCtx.beginPath();
            gCtx.moveTo(0, origin.y);
            gCtx.lineTo(size.w, origin.y);
            gCtx.stroke();
            gCtx.beginPath();
            gCtx.moveTo(origin.x, 0);
            gCtx.lineTo(origin.x, size.h);
            gCtx.stroke();
        }
        
        function drawEndpoint(pt, type, ctx, size, isDraggable = false) {
            const screen = toScreen(pt, size);
            ctx.save();
            ctx.strokeStyle = isDraggable ? "#f59e0b" : "#1e40af";
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            ctx.arc(screen.x, screen.y, isDraggable ? 7 : 5, 0, 2 * Math.PI);
            // Only fill if it's closed (not open)
            if (type === "closed") {
                ctx.fillStyle = isDraggable ? "#f59e0b" : "#1e40af";
                ctx.fill();
            } else if (type === "open") {
                // For open endpoints, draw empty circle
                ctx.fillStyle = "white";
                ctx.fill();
            }
            ctx.stroke();
            ctx.restore();
        }
        
        function drawSegment(seg, isSelected) {
            const size = cssSize(mainCv);
            
            mCtx.strokeStyle = isSelected ? "#f59e0b" : "#0f766e";
            mCtx.lineWidth = isSelected ? 3.5 : 2.5;
            
            // Calculate drawing bounds for infinity
            let p1Draw = {...seg.p1};
            let p2Draw = {...seg.p2};
            
            if (seg.startType === "-infty") {
                p1Draw.x = WMIN + 0.2; // Near left edge
            }
            
            if (seg.endType === "+infty") {
                p2Draw.x = WMAX - 0.2; // Near right edge
            }
            
            const p1Screen = toScreen(p1Draw, size);
            const p2Screen = toScreen(p2Draw, size);
            
            mCtx.beginPath();
            mCtx.moveTo(p1Screen.x, p1Screen.y);
            
            if (seg.type === "line") {
                // Use slope handles to create a cubic bezier for smooth directional control
                if (seg.slopeHandle1 && seg.slopeHandle2) {
                    const sh1Screen = toScreen(seg.slopeHandle1, size);
                    const sh2Screen = toScreen(seg.slopeHandle2, size);
                    mCtx.bezierCurveTo(sh1Screen.x, sh1Screen.y, sh2Screen.x, sh2Screen.y, p2Screen.x, p2Screen.y);
                } else {
                    mCtx.lineTo(p2Screen.x, p2Screen.y);
                }
            } else {
                // Draw quadratic curve as before
                const handleScreen = toScreen(seg.handle, size);
                mCtx.quadraticCurveTo(handleScreen.x, handleScreen.y, p2Screen.x, p2Screen.y);
            }
            
            mCtx.stroke();
            
            // Draw endpoints (only for non-infinity)
            if (seg.startType !== "-infty") {
                drawEndpoint(seg.p1, seg.startType, mCtx, size);
            }
            
            if (seg.endType !== "+infty") {
                drawEndpoint(seg.p2, seg.endType, mCtx, size);
            }
        }
        
        function drawHandles() {
            const size = cssSize(handleCv);
            hCtx.clearRect(0, 0, size.w, size.h);
            
            if (state.sel === null) return;
            const seg = state.segments[state.sel];
            
            // Draw draggable endpoints for y-value adjustment
            const p1Screen = toScreen(seg.p1, size);
            const p2Screen = toScreen(seg.p2, size);
            
            // Endpoint 1
            if (seg.startType !== "-infty") {
                hCtx.save();
                hCtx.fillStyle = "#f59e0b";
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.beginPath();
                hCtx.arc(p1Screen.x, p1Screen.y, 8, 0, 2 * Math.PI);
                hCtx.fill();
                hCtx.stroke();
                hCtx.restore();
            }
            
            // Endpoint 2
            if (seg.endType !== "+infty") {
                hCtx.save();
                hCtx.fillStyle = "#f59e0b";
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.beginPath();
                hCtx.arc(p2Screen.x, p2Screen.y, 8, 0, 2 * Math.PI);
                hCtx.fill();
                hCtx.stroke();
                hCtx.restore();
            }
            
            // Draw slope handles for lines (always show for selected segment)
            if (seg.type === 'line' && seg.slopeHandle1 && seg.slopeHandle2) {
                const sh1Screen = toScreen(seg.slopeHandle1, size);
                const sh2Screen = toScreen(seg.slopeHandle2, size);
                
                // Draw guide lines from endpoints to slope handles
                hCtx.beginPath();
                hCtx.setLineDash([3, 4]);
                hCtx.moveTo(p1Screen.x, p1Screen.y);
                hCtx.lineTo(sh1Screen.x, sh1Screen.y);
                hCtx.strokeStyle = "#dc2626aa";
                hCtx.lineWidth = 1.5;
                hCtx.stroke();
                
                hCtx.beginPath();
                hCtx.moveTo(p2Screen.x, p2Screen.y);
                hCtx.lineTo(sh2Screen.x, sh2Screen.y);
                hCtx.stroke();
                hCtx.setLineDash([]);
                
                // Draw slope handle 1
                hCtx.beginPath();
                hCtx.arc(sh1Screen.x, sh1Screen.y, 6, 0, 2 * Math.PI);
                hCtx.fillStyle = "#dc2626";
                hCtx.fill();
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.stroke();
                
                // Draw slope handle 2
                hCtx.beginPath();
                hCtx.arc(sh2Screen.x, sh2Screen.y, 6, 0, 2 * Math.PI);
                hCtx.fillStyle = "#dc2626";
                hCtx.fill();
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.stroke();
            }
            
            // Draw curve handle if it's a curve and handles are shown
            if (seg.type === 'curve' && state.showHandles) {
                const handleScreen = toScreen(seg.handle, size);
                
                // Draw guide lines
                hCtx.beginPath();
                hCtx.setLineDash([3, 4]);
                hCtx.moveTo(p1Screen.x, p1Screen.y);
                hCtx.lineTo(handleScreen.x, handleScreen.y);
                hCtx.lineTo(p2Screen.x, p2Screen.y);
                hCtx.strokeStyle = "#10b981aa";
                hCtx.lineWidth = 1.5;
                hCtx.stroke();
                hCtx.setLineDash([]);
                
                // Draw handle
                hCtx.beginPath();
                hCtx.arc(handleScreen.x, handleScreen.y, 8, 0, 2 * Math.PI);
                hCtx.fillStyle = "#10b981";
                hCtx.fill();
                hCtx.strokeStyle = "#222";
                hCtx.lineWidth = 1;
                hCtx.stroke();
            }
        }
        
        function drawAll() {
            const size = cssSize(mainCv);
            drawGrid();
            mCtx.clearRect(0, 0, size.w, size.h);
            state.segments.forEach((seg, i) => drawSegment(seg, i === state.sel));
            drawHandles();
        }
        
        // Canvas interaction - Draggable endpoints and handles
        function mouseWorld(e) {
            const rect = handleCv.getBoundingClientRect();
            return fromScreen({ x: e.clientX - rect.left, y: e.clientY - rect.top }, cssSize(handleCv));
        }
        
        function getHitTarget(pt) {
            if (state.sel === null) return null;
            const seg = state.segments[state.sel];
            const thresh = 0.5;
            
            // Check endpoints
            if (seg.startType !== "-infty") {
                const dx = pt.x - seg.p1.x;
                const dy = pt.y - seg.p1.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return { type: 'p1', index: state.sel };
                }
            }
            
            if (seg.endType !== "+infty") {
                const dx = pt.x - seg.p2.x;
                const dy = pt.y - seg.p2.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return { type: 'p2', index: state.sel };
                }
            }
            
            // Check slope handles for lines
            if (seg.type === 'line' && seg.slopeHandle1 && seg.slopeHandle2) {
                // Slope handle 1
                const dx1 = pt.x - seg.slopeHandle1.x;
                const dy1 = pt.y - seg.slopeHandle1.y;
                if (Math.sqrt(dx1 * dx1 + dy1 * dy1) < thresh) {
                    return { type: 'slopeHandle1', index: state.sel };
                }
                
                // Slope handle 2
                const dx2 = pt.x - seg.slopeHandle2.x;
                const dy2 = pt.y - seg.slopeHandle2.y;
                if (Math.sqrt(dx2 * dx2 + dy2 * dy2) < thresh) {
                    return { type: 'slopeHandle2', index: state.sel };
                }
            }
            
            // Check curve handle
            if (seg.type === 'curve' && state.showHandles) {
                const dx = pt.x - seg.handle.x;
                const dy = pt.y - seg.handle.y;
                if (Math.sqrt(dx * dx + dy * dy) < thresh) {
                    return { type: 'handle', index: state.sel };
                }
            }
            
            return null;
        }
        
        function canvasDown(e) {
            const pt = mouseWorld(e);
            const hit = getHitTarget(pt);
            
            if (hit) {
                state.drag.endpointIdx = hit.index;
                state.drag.endpointType = hit.type;
                handleCv.style.cursor = "grabbing";
            }
        }
        
        function canvasMove(e) {
            const pt = mouseWorld(e);
            
            if (state.drag.endpointIdx !== null) {
                // Dragging
                const seg = state.segments[state.drag.endpointIdx];
                
                if (state.drag.endpointType === 'p1') {
                    seg.p1.y = +pt.y.toFixed(2);
                } else if (state.drag.endpointType === 'p2') {
                    seg.p2.y = +pt.y.toFixed(2);
                } else if (state.drag.endpointType === 'handle') {
                    seg.handle.x = +pt.x.toFixed(2);
                    seg.handle.y = +pt.y.toFixed(2);
                } else if (state.drag.endpointType === 'slopeHandle1') {
                    seg.slopeHandle1.x = +pt.x.toFixed(2);
                    seg.slopeHandle1.y = +pt.y.toFixed(2);
                } else if (state.drag.endpointType === 'slopeHandle2') {
                    seg.slopeHandle2.x = +pt.x.toFixed(2);
                    seg.slopeHandle2.y = +pt.y.toFixed(2);
                }
                
                refresh();
            } else {
                // Hovering
                const hit = getHitTarget(pt);
                handleCv.style.cursor = hit ? "grab" : "default";
            }
        }
        
        function canvasUp() {
            if (state.drag.endpointIdx !== null) {
                pushUndo();
            }
            state.drag.endpointIdx = null;
            state.drag.endpointType = null;
            handleCv.style.cursor = "default";
        }
        
        // Analysis - FIXED FUNCTION TEST
        function runAnalysis() {
            const results = document.getElementById('analysis-results');
            const graphSegs = state.segments;
            
            if (graphSegs.length === 0) {
                results.innerHTML = 'Add segments to begin analysis.';
                return;
            }
            
            state.lastAnalysis = analyzeFunction(graphSegs);
            results.innerHTML = state.lastAnalysis.display;
        }
        
        function analyzeFunction(segments) {
            // Check if it's a function - properly check for overlapping x-intervals
            const checkIntervals = [];
            segments.forEach(s => {
                const xMin = Math.min(s.p1.x, s.p2.x);
                const xMax = Math.max(s.p1.x, s.p2.x);
                checkIntervals.push({ 
                    start: xMin, 
                    end: xMax,
                    segment: s
                });
            });
            
            checkIntervals.sort((a, b) => a.start - b.start);
            let isFunction = true;
            let overlapDetails = null;
            
            // Check for overlapping intervals (excluding endpoints that are open)
            for (let i = 0; i < checkIntervals.length; i++) {
                for (let j = i + 1; j < checkIntervals.length; j++) {
                    const int1 = checkIntervals[i];
                    const int2 = checkIntervals[j];
                    
                    // Check if intervals overlap (not just touch at endpoints)
                    if (int1.end > int2.start && int1.start < int2.end) {
                        // There's an overlap - this violates the function rule
                        isFunction = false;
                        overlapDetails = `Segments overlap between x=${Math.max(int1.start, int2.start).toFixed(1)} and x=${Math.min(int1.end, int2.end).toFixed(1)}`;
                        break;
                    }
                    
                    // Also check if they share an x-value where both have defined y-values
                    if (Math.abs(int1.end - int2.start) < 0.001) {
                        // They meet at a point - check if both segments claim this point
                        const seg1 = int1.segment;
                        const seg2 = int2.segment;
                        
                        // Determine which endpoint of seg1 is at the meeting point
                        const seg1RightEnd = seg1.p1.x < seg1.p2.x ? seg1.p2 : seg1.p1;
                        const seg1RightType = seg1.p1.x < seg1.p2.x ? seg1.endType : seg1.startType;
                        
                        // Determine which endpoint of seg2 is at the meeting point  
                        const seg2LeftEnd = seg2.p1.x < seg2.p2.x ? seg2.p1 : seg2.p2;
                        const seg2LeftType = seg2.p1.x < seg2.p2.x ? seg2.startType : seg2.endType;
                        
                        // Both closed at meeting point means both claim the x-value
                        if (seg1RightType === 'closed' && seg2LeftType === 'closed') {
                            // Check if they have the same y-value
                            if (Math.abs(seg1RightEnd.y - seg2LeftEnd.y) > 0.001) {
                                isFunction = false;
                                overlapDetails = `Multiple y-values at x=${int1.end.toFixed(1)} (y=${seg1RightEnd.y.toFixed(1)} and y=${seg2LeftEnd.y.toFixed(1)})`;
                                break;
                            }
                        }
                    }
                }
                if (!isFunction) break;
            }
            
            if (!isFunction) {
                return {
                    isFunction: false,
                    display: `<strong>Function test:</strong> <span style="color: var(--accent-red); font-weight: bold;">❌ Fails</span><br>${overlapDetails}`
                };
            }
            
            // Analyze properties
            let increasing = [], decreasing = [], constant = [], concaveUp = [], concaveDown = [];
            let domainParts = [];
            let fullRange = [Infinity, -Infinity];
            
            segments.sort((a, b) => Math.min(a.p1.x, a.p2.x) - Math.min(b.p1.x, b.p2.x));
            
            segments.forEach(s => {
                domainParts.push({ 
                    start: s.p1.x, 
                    end: s.p2.x, 
                    startType: s.startType, 
                    endType: s.endType 
                });
                
                [s.p1, s.p2, s.handle].filter(Boolean).forEach(p => {
                    fullRange[0] = Math.min(fullRange[0], p.y);
                    fullRange[1] = Math.max(fullRange[1], p.y);
                });
                
                const p1 = s.p1.x <= s.p2.x ? s.p1 : s.p2;
                const p2 = s.p1.x <= s.p2.x ? s.p2 : s.p1;
                const interval = {
                    start: p1.x,
                    end: p2.x,
                    startType: p1 === s.p1 ? s.startType : s.endType,
                    endType: p2 === s.p2 ? s.endType : s.startType
                };
                
                if (s.type === 'line') {
                    if (Math.abs(p1.y - p2.y) < 1e-6) constant.push(interval);
                    else if (p1.y < p2.y) increasing.push(interval);
                    else decreasing.push(interval);
                } else if (s.type === 'curve') {
                    // Simple analysis for curves
                    const h = s.handle;
                    const y_dd = 2 * (s.p1.y - 2 * h.y + s.p2.y);
                    
                    if (Math.abs(y_dd) > 1e-6) {
                        if (y_dd > 0) concaveUp.push(interval);
                        else concaveDown.push(interval);
                    }
                    
                    // Monotonicity
                    if (Math.abs(p1.y - p2.y) < 1e-6) constant.push(interval);
                    else if (p1.y < p2.y) increasing.push(interval);
                    else decreasing.push(interval);
                }
            });
            
            function formatIntervals(arr) {
                if (arr.length === 0) return 'None';
                return arr.sort((a, b) => a.start - b.start).map(i => {
                    const open = i.startType === 'open' ? '(' : i.startType === '-infty' ? '(-∞' : '[';
                    const close = i.endType === 'open' ? ')' : i.endType === '+infty' ? '∞)' : ']';
                    const start = i.startType === '-infty' ? '' : i.start.toFixed(1);
                    const end = i.endType === '+infty' ? '' : i.end.toFixed(1);
                    return `${open}${start}, ${end}${close}`;
                }).join(' ∪ ');
            }
            
            return {
                isFunction: true,
                domain: formatIntervals(domainParts),
                range: `[${fullRange[0].toFixed(1)}, ${fullRange[1].toFixed(1)}]`,
                increasing: formatIntervals(increasing),
                decreasing: formatIntervals(decreasing),
                constant: formatIntervals(constant),
                concaveUp: formatIntervals(concaveUp),
                concaveDown: formatIntervals(concaveDown),
                hasIncreasing: increasing.length > 0,
                hasDecreasing: decreasing.length > 0,
                hasConstant: constant.length > 0,
                hasConcaveUp: concaveUp.length > 0,
                hasConcaveDown: concaveDown.length > 0,
                display: `
                    <strong>Function test:</strong> <span style="color: var(--success); font-weight: bold;">✅ Passes</span><br>
                    <strong>Domain:</strong> ${formatIntervals(domainParts)}<br>
                    <strong>Range:</strong> [${fullRange[0].toFixed(1)}, ${fullRange[1].toFixed(1)}]<br>
                    <strong>Increasing:</strong> ${formatIntervals(increasing)}<br>
                    <strong>Decreasing:</strong> ${formatIntervals(decreasing)}<br>
                    <strong>Constant:</strong> ${formatIntervals(constant)}<br>
                    <strong>Concave Up:</strong> ${formatIntervals(concaveUp)}<br>
                    <strong>Concave Down:</strong> ${formatIntervals(concaveDown)}
                `.trim()
            };
        }
        
        // Function Challenge Functions - SIMPLE AND FOCUSED
        function generateNewChallenge() {
            const feedback = document.getElementById('challenge-feedback');
            feedback.classList.remove('show');
            state.attempts = 0;
            state.challengeNumber++;
            
            // Helper functions
            const rand = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
            const coinFlip = () => Math.random() < 0.5;
            
            // Generate domain
            const domainTypes = ['finite', 'left-infinite', 'right-infinite'];
            const domainType = domainTypes[Math.floor(Math.random() * domainTypes.length)];
            
            let domain = '';
            switch(domainType) {
                case 'finite':
                    const a = rand(-6, -2);
                    const b = rand(2, 6);
                    domain = `[${a}, ${b}]`;
                    break;
                case 'left-infinite':
                    domain = `(-∞, ${rand(0, 4)}]`;
                    break;
                case 'right-infinite':
                    domain = `[${rand(-4, 0)}, ∞)`;
                    break;
            }
            
            // Focus on fundamental properties only
            const fundamentalProperties = [
                'an increasing interval',
                'a decreasing interval', 
                'a constant interval',
                'both increasing and decreasing intervals',
                'concave up somewhere (use curves!)',
                'concave down somewhere (use curves!)',
                'both concave up and concave down',
                'a local maximum',
                'a local minimum',
                `maximum value of ${rand(3, 5)}`,
                `minimum value of ${rand(-5, -3)}`,
                `passes through origin (0, 0)`,
                'continuous (no jumps)',
                'at least one jump discontinuity',
                'mix of open and closed endpoints'
            ];
            
            // Select 2-3 properties
            const numProperties = rand(2, 3);
            const selectedProperties = [];
            const availableProps = [...fundamentalProperties];
            
            for (let i = 0; i < numProperties && availableProps.length > 0; i++) {
                const index = Math.floor(Math.random() * availableProps.length);
                const prop = availableProps[index];
                
                // Simple conflict check
                let hasConflict = false;
                for (const selected of selectedProperties) {
                    if ((prop.includes('continuous') && selected.includes('discontinuity')) ||
                        (prop.includes('discontinuity') && selected.includes('continuous'))) {
                        hasConflict = true;
                        break;
                    }
                }
                
                if (!hasConflict) {
                    selectedProperties.push(prop);
                }
                availableProps.splice(index, 1);
            }
            
            state.currentChallenge = {
                domain: domain,
                properties: selectedProperties,
                number: state.challengeNumber
            };
            
            // Display challenge
            const reqDiv = document.getElementById('requirements');
            let html = `<div class="challenge-requirement" style="font-size: 0.85em; color: var(--text-muted); font-style: italic;">
                     Note: Challenge numbers track your progress, not difficulty level</div>`;
            html += `<div class="challenge-requirement"><strong>Domain:</strong> ${state.currentChallenge.domain}</div>`;
            state.currentChallenge.properties.forEach(p => {
                html += `<div class="challenge-requirement">• Has ${p}</div>`;
            });
            reqDiv.innerHTML = html;
            
            // Update badge
            const badge = document.getElementById('challenge-badge');
            if (badge) {
                badge.textContent = `Challenge #${state.challengeNumber}`;
            }
        }
        
        function checkChallenge() {
            const feedback = document.getElementById('challenge-feedback');
            
            if (!state.lastAnalysis || !state.lastAnalysis.isFunction) {
                feedback.innerHTML = "❌ Your graph must be a valid function first!";
                feedback.className = 'feedback-box warning show';
                return;
            }
            
            let passed = true;
            let issues = [];
            
            state.currentChallenge.properties.forEach(prop => {
                let satisfied = false;
                
                // Check properties
                if (prop.includes('increasing') && prop.includes('interval')) {
                    satisfied = state.lastAnalysis.hasIncreasing;
                } else if (prop.includes('decreasing') && prop.includes('interval')) {
                    satisfied = state.lastAnalysis.hasDecreasing;
                } else if (prop.includes('constant') && prop.includes('interval')) {
                    satisfied = state.lastAnalysis.hasConstant;
                } else if (prop.includes('concave up')) {
                    satisfied = state.lastAnalysis.hasConcaveUp;
                } else if (prop.includes('concave down')) {
                    satisfied = state.lastAnalysis.hasConcaveDown;
                } else if (prop.includes('both increasing and decreasing')) {
                    satisfied = state.lastAnalysis.hasIncreasing && state.lastAnalysis.hasDecreasing;
                } else if (prop.includes('both concave')) {
                    satisfied = state.lastAnalysis.hasConcaveUp && state.lastAnalysis.hasConcaveDown;
                } else {
                    // For other properties, assume satisfied (visual verification)
                    satisfied = true;
                }
                
                if (!satisfied) {
                    passed = false;
                    issues.push(prop);
                }
            });
            
            if (passed) {
                feedback.innerHTML = `✅ Excellent! Challenge #${state.challengeNumber} complete!<br>
                                     Ready for Challenge #${state.challengeNumber + 1}?`;
                feedback.className = 'feedback-box success show';
            } else {
                state.attempts++;
                feedback.innerHTML = `⚠️ Not quite! Your function still needs:<br>
                                     <strong>${issues.join(', ')}</strong><br>
                                     ${state.attempts > 2 ? "Check the Live Analysis for help." : "Keep trying!"}`;
                feedback.className = 'feedback-box warning show';
            }
        }
        
        function getHint() {
            const feedback = document.getElementById('challenge-feedback');
            const hints = [
                "Drag the yellow endpoints up/down to change function behavior",
                "Drag the green handle to adjust curve shape",
                "Click brackets to toggle open/closed endpoints",
                "Constant means same y-value at both ends",
                "Use (-∞ or +∞) to extend your function to the edges",
                "Check the Live Analysis to see your current properties"
            ];
            
            feedback.innerHTML = `💡 ${hints[Math.floor(Math.random() * hints.length)]}`;
            feedback.className = 'feedback-box show';
        }
    </script>
</body>
</html>
