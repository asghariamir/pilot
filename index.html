<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Function Behavior Cards | Mathswell</title>
  <link rel="icon" href="/logo-mathswell-square-mirror.ico" type="image/x-icon">
  <link rel="icon" href="/logo-mathswell-square-mirror.svg" type="image/svg+xml">
  <style>
    :root {
      --primary: #0f766e;
      --primary-light: #10b981;
      --primary-dark: #0a5a52;
      --background: #f7faf9;
      --interactive: #e6fffb;
      --text-primary: #212121;
      --text-muted: #4b5563;
      --accent-amber: #f59e0b;
      --accent-red: #dc2626;
      --accent-blue: #2563eb;
      --surface: #ffffff;
      --border: #e0e7e4;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #dc2626;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
      background: linear-gradient(135deg, var(--background) 0%, #f0f9f8 100%);
      color: var(--text-primary);
      line-height: 1.6;
      min-height: 100vh;
    }

    .mathswell-nav {
      display: flex;
      justify-content: center;
      margin: 1.5rem 0;
      padding: 0.5rem;
    }

    .mw-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      text-decoration: none;
      font-weight: 700;
      color: var(--primary);
      padding: 0.5rem 1rem;
      border-radius: 999px;
      background: #fff;
      box-shadow: 0 2px 8px rgba(15, 118, 110, 0.1);
      transition: all 0.3s ease;
    }

    .mw-link:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.2);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      background: white;
      border-radius: 12px;
      padding: 0.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      justify-content: center;
    }

    .tab-btn {
      padding: 0.75rem 1.5rem;
      background: transparent;
      border: none;
      color: var(--text-muted);
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      border-radius: 8px;
      flex: 1;
      max-width: 200px;
    }

    .tab-btn:hover {
      background: var(--interactive);
      color: var(--primary);
    }

    .tab-btn.active {
      color: white;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      box-shadow: 0 2px 8px rgba(15, 118, 110, 0.15);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    .hero {
      background: linear-gradient(135deg, #fff, var(--interactive));
      padding: 2.5rem;
      border-radius: 16px;
      margin-bottom: 2rem;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
      text-align: center;
    }

    .hero h1 {
      color: var(--primary);
      margin-bottom: 1rem;
      font-size: 2.2rem;
      font-weight: 700;
    }

    .hero p {
      color: var(--text-muted);
      font-size: 1.1rem;
      max-width: 700px;
      margin: 0 auto;
    }

    .examples-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.5rem;
      margin-bottom: 2rem;
    }

    .example-card {
      background: #fff;
      padding: 1.5rem;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      border: 1px solid var(--border);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
    }

    .example-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
      border-color: var(--primary-light);
    }

    .example-card h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      font-size: 1.1rem;
      text-align: center;
    }

    .example-canvas {
      width: 100%;
      height: 120px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: #fff;
      margin-bottom: 0.5rem;
      display: block;
    }

    .example-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      right: 10px;
      background: var(--interactive);
      padding: 0.5rem;
      border-radius: 6px;
      font-size: 0.85rem;
      text-align: center;
      display: none;
    }

    .example-card.show-math .example-info.math,
    .example-card.show-interval .example-info.interval {
      display: block;
    }

    /* Read Tab Styles - Updated rectangular cards */
    .card-bank {
      background: linear-gradient(135deg, var(--interactive), #f8fffe);
      padding: 1.5rem;
      border-radius: 12px;
      margin-bottom: 2rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    }

    .card-bank h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      font-size: 1.2rem;
      text-align: center;
    }

    .cards-container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 0.75rem;
      min-height: 80px;
    }

    .word-card {
      padding: 1rem;
      background: white;
      border: 2px solid var(--primary);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      user-select: none;
      font-weight: 600;
      color: var(--primary);
      text-align: center;
      min-height: 60px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .word-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.2);
      background: var(--interactive);
    }

    .word-card.selected {
      background: var(--primary);
      color: white;
    }

    .word-card.dragging {
      opacity: 0.5;
    }

    .sequence-area {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      margin-bottom: 2rem;
      min-height: 200px;
    }

    .sequence-area h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      text-align: center;
    }

    .sequence-container {
      display: flex;
      gap: 0.75rem;
      padding: 1.5rem;
      background: var(--interactive);
      border-radius: 8px;
      min-height: 100px;
      align-items: center;
      flex-wrap: wrap;
      border: 2px dashed var(--primary);
      justify-content: center;
    }

    .sequence-container.drag-over {
      background: #d1f4f0;
      border-color: var(--primary-light);
    }

    .sequence-container .word-card {
      min-width: 120px;
      padding: 0.75rem;
      min-height: 50px;
    }

    /* Build Tab Styles */
    .interval-selector {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    }

    .interval-selector h3 {
      color: var(--primary);
      margin-bottom: 1.5rem;
      text-align: center;
      font-size: 1.3rem;
    }

    .interval-builder {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      justify-content: center;
      margin-bottom: 1.5rem;
      padding: 1.5rem;
      background: linear-gradient(135deg, var(--interactive), #f0fffc);
      border-radius: 12px;
      border: 2px solid var(--primary-light);
    }

    .bracket-toggle {
      width: 45px;
      height: 50px;
      font-size: 1.6rem;
      border: 2px solid var(--primary);
      background: white;
      cursor: pointer;
      transition: all 0.2s;
      border-radius: 6px;
      font-weight: 500;
      color: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .bracket-toggle.closed {
      background: var(--primary);
      color: white;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(15, 118, 110, 0.3);
    }

    .bracket-toggle:hover {
      transform: scale(1.08);
      box-shadow: 0 2px 8px rgba(15, 118, 110, 0.2);
    }

    .interval-input {
      width: 80px;
      padding: 0.75rem;
      border: 2px solid var(--border);
      border-radius: 8px;
      text-align: center;
      font-size: 1.1rem;
      font-weight: 600;
      transition: all 0.2s;
      background: white;
    }

    .interval-input:focus {
      border-color: var(--primary);
      outline: none;
      box-shadow: 0 0 0 3px rgba(15, 118, 110, 0.1);
    }

    .infinity-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
      user-select: none;
      padding: 0.5rem;
      border-radius: 6px;
      transition: all 0.2s;
    }

    .infinity-toggle:hover {
      background: var(--interactive);
    }

    .infinity-checkbox {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .infinity-label {
      font-size: 1.1rem;
      color: var(--primary);
      font-weight: 600;
    }

    .comma {
      font-size: 1.4rem;
      color: var(--text-muted);
      font-weight: 600;
    }

    .add-interval-btn {
      padding: 0.75rem 2rem;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.2s;
      box-shadow: 0 2px 4px rgba(15, 118, 110, 0.2);
    }

    .add-interval-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(15, 118, 110, 0.3);
    }

    .preset-intervals {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
      justify-content: center;
      padding-top: 1.5rem;
      border-top: 2px dashed var(--border);
    }

    .preset-label {
      width: 100%;
      text-align: center;
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
    }

    .preset-btn {
      padding: 0.5rem 1rem;
      background: white;
      border: 2px solid var(--primary);
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
      color: var(--primary);
      font-weight: 600;
    }

    .preset-btn:hover {
      background: var(--interactive);
      transform: translateY(-2px);
      box-shadow: 0 2px 4px rgba(15, 118, 110, 0.2);
    }

    .visual-behaviors {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    }

    .visual-behaviors h3 {
      color: var(--primary);
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .visual-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .visual-card {
      background: white;
      border: 2px solid var(--border);
      border-radius: 12px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .visual-card:hover {
      border-color: var(--primary);
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.2);
    }

    .visual-card.active {
      background: var(--primary);
      border-color: var(--primary-dark);
    }

    .visual-card canvas {
      width: 100%;
      height: 100%;
    }

    .segments-display {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    }

    .segments-display h3 {
      color: var(--primary);
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .segments-list {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      min-height: 100px;
      padding: 1rem;
      background: var(--interactive);
      border-radius: 8px;
      border: 2px dashed var(--primary);
      justify-content: center;
      align-items: center;
    }

    .segment-item {
      background: white;
      border: 2px solid var(--primary);
      border-radius: 8px;
      padding: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
      min-width: 150px;
    }

    .segment-item:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(15, 118, 110, 0.2);
    }

    .segment-item.selected {
      background: var(--primary-light);
      border-color: var(--primary-dark);
      transform: scale(1.05);
    }

    .segment-item canvas {
      width: 100%;
      height: 60px;
      display: block;
      margin-bottom: 0.5rem;
    }

    .segment-label {
      text-align: center;
      font-size: 0.9rem;
      color: var(--primary);
      font-weight: 600;
    }

    .remove-segment {
      position: absolute;
      top: -8px;
      right: -8px;
      width: 24px;
      height: 24px;
      background: var(--error);
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      font-weight: bold;
      font-size: 0.9rem;
    }

    .connections-panel {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
    }

    .connections-panel h3 {
      color: var(--primary);
      margin-bottom: 1.5rem;
      text-align: center;
    }

    .connection-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      margin-bottom: 1.5rem;
      max-width: 700px;
      margin: 0 auto;
    }

    .connection-card {
      background: white;
      border: 2px solid var(--primary);
      border-radius: 12px;
      padding: 1.5rem;
      cursor: pointer;
      transition: all 0.3s ease;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .connection-card:hover:not(:disabled) {
      transform: translateY(-3px);
      box-shadow: 0 4px 12px rgba(15, 118, 110, 0.2);
      background: var(--interactive);
    }

    .connection-card:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connection-card canvas {
      width: 100%;
      height: 100%;
    }

    .asymptote-controls {
      display: flex;
      gap: 1rem;
      align-items: center;
      padding: 1rem;
      background: var(--interactive);
      border-radius: 8px;
      margin-top: 1.5rem;
    }

    .asymptote-list {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
    }

    .asymptote-tag {
      padding: 0.5rem 1rem;
      background: white;
      border: 2px solid var(--primary);
      border-radius: 999px;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .asymptote-tag button {
      background: var(--error);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .graph-display {
      background: white;
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
      margin-bottom: 2rem;
    }

    .graph-display h3 {
      color: var(--primary);
      margin-bottom: 1rem;
      text-align: center;
    }

    .graph-canvas {
      width: 100%;
      height: 400px;
      border: 2px solid var(--border);
      border-radius: 8px;
      background: white;
      display: block;
    }

    .controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.95rem;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: white;
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(15, 118, 110, 0.3);
    }

    .btn-secondary {
      background: white;
      color: var(--primary);
      border: 2px solid var(--primary);
    }

    .btn-secondary:hover {
      background: var(--interactive);
    }

    .feedback {
      padding: 1rem;
      border-radius: 8px;
      margin-top: 1rem;
      display: none;
      border-left: 4px solid;
      text-align: center;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .feedback.show {
      display: block;
    }

    .feedback.success {
      background: #d4edda;
      color: #155724;
      border-left-color: var(--success);
    }

    .feedback.error {
      background: #f8d7da;
      color: #721c24;
      border-left-color: var(--error);
    }

    .feedback.info {
      background: #cce5ff;
      color: #004085;
      border-left-color: var(--accent-blue);
    }

    .sentence-display {
      background: linear-gradient(135deg, #e8f5e9, #c8e6c9);
      padding: 1.5rem;
      border-radius: 8px;
      margin-top: 1rem;
      font-size: 1.1rem;
      text-align: center;
      color: var(--primary-dark);
      animation: celebrate 0.5s ease;
    }

    @keyframes celebrate {
      0% { transform: scale(0.95); opacity: 0; }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); opacity: 1; }
    }

    .challenge-box {
      background: linear-gradient(135deg, #fffbeb, #fef3c7);
      padding: 1.5rem;
      border-radius: 12px;
      border: 2px solid var(--accent-amber);
      margin-bottom: 2rem;
      text-align: center;
    }

    .challenge-box h4 {
      color: #92400e;
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    .challenge-text {
      color: #451a03;
      font-size: 1.2rem;
      font-weight: 600;
    }

    .placeholder-text {
      color: var(--text-muted);
      font-style: italic;
      text-align: center;
      padding: 2rem;
    }

    .cta-buttons {
      text-align: center;
      margin-top: 2rem;
      display: flex;
      gap: 1rem;
      justify-content: center;
    }

    @media (max-width: 768px) {
      .tabs {
        flex-direction: column;
      }
      
      .tab-btn {
        max-width: 100%;
      }
      
      .cards-container {
        grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      }
      
      .interval-builder {
        flex-direction: column;
        gap: 1rem;
      }
      
      .visual-grid {
        grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="mathswell-nav">
    <a href="/" class="mw-link">
      <img src="/logo-mathswell-square-mirror.svg" alt="Mathswell" width="28" height="28">
      <span>MATHSWELL</span>
    </a>
  </div>

  <div class="container">
    <div class="tabs">
      <button class="tab-btn active" data-tab="intro">Introduction</button>
      <button class="tab-btn" data-tab="read">Read the Graph</button>
      <button class="tab-btn" data-tab="build">Build from Text</button>
    </div>

    <!-- INTRODUCTION TAB -->
    <div id="intro" class="tab-content active">
      <div class="hero">
        <h1>Function Behavior Cards</h1>
        <p>Master function analysis by recognizing behaviors visually and describing them mathematically. Click examples to see notation.</p>
      </div>

      <div class="examples-grid">
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Increasing</h3>
          <canvas class="example-canvas" id="ex-inc"></canvas>
          <div class="example-info math">f'(x) > 0</div>
          <div class="example-info interval">on (a, b)</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Decreasing</h3>
          <canvas class="example-canvas" id="ex-dec"></canvas>
          <div class="example-info math">f'(x) < 0</div>
          <div class="example-info interval">on (a, b)</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Concave Up</h3>
          <canvas class="example-canvas" id="ex-cup"></canvas>
          <div class="example-info math">f''(x) > 0</div>
          <div class="example-info interval">on (a, b)</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Concave Down</h3>
          <canvas class="example-canvas" id="ex-cdown"></canvas>
          <div class="example-info math">f''(x) < 0</div>
          <div class="example-info interval">on (a, b)</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Corner</h3>
          <canvas class="example-canvas" id="ex-corner"></canvas>
          <div class="example-info math">f'(c⁻) ≠ f'(c⁺)</div>
          <div class="example-info interval">at x = c</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Cusp</h3>
          <canvas class="example-canvas" id="ex-cusp"></canvas>
          <div class="example-info math">|f'(x)| → ∞</div>
          <div class="example-info interval">as x → c</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Inflection Point</h3>
          <canvas class="example-canvas" id="ex-inflect"></canvas>
          <div class="example-info math">f''(x) changes sign</div>
          <div class="example-info interval">at x = c</div>
        </div>
        <div class="example-card" onclick="toggleExampleInfo(this)">
          <h3>Jump Discontinuity</h3>
          <canvas class="example-canvas" id="ex-jump"></canvas>
          <div class="example-info math">lim x→c⁻ ≠ lim x→c⁺</div>
          <div class="example-info interval">at x = c</div>
        </div>
      </div>

      <div class="cta-buttons">
        <button class="btn btn-primary" onclick="switchToTab('read')">Try Reading Graphs →</button>
        <button class="btn btn-primary" onclick="switchToTab('build')">Build Functions →</button>
      </div>
    </div>

    <!-- READ THE GRAPH TAB -->
    <div id="read" class="tab-content">
      <div class="graph-display">
        <h3>Analyze This Function</h3>
        <canvas class="graph-canvas" id="read-graph"></canvas>
        <div class="controls">
          <button class="btn btn-secondary" onclick="generateNewReadProblem()">New Function</button>
        </div>
      </div>

      <div class="card-bank">
        <h3>Behavior Word Cards</h3>
        <p style="text-align: center; color: var(--text-muted); font-size: 0.9rem; margin-bottom: 1rem;">
          Click to select/unselect, or drag to describe the function
        </p>
        <div class="cards-container" id="read-cards">
          <!-- Word cards will be generated here -->
        </div>
      </div>

      <div class="sequence-area">
        <h3>Your Description</h3>
        <div class="sequence-container" id="read-sequence">
          <div class="placeholder-text">Drag word cards here or click selected cards to remove</div>
        </div>
        <div class="controls">
          <button class="btn btn-primary" onclick="checkReadAnswer()">Check Answer</button>
          <button class="btn btn-secondary" onclick="clearReadSequence()">Clear</button>
          <button class="btn btn-secondary" onclick="getHint()">Hint</button>
        </div>
        <div class="feedback" id="read-feedback"></div>
        <div id="sentence-display"></div>
      </div>
    </div>

    <!-- BUILD FROM TEXT TAB -->
    <div id="build" class="tab-content">
      <div class="challenge-box">
        <h4>Build This Function:</h4>
        <div class="challenge-text" id="build-challenge">
          A function that is increasing and concave up
        </div>
        <div class="controls">
          <button class="btn btn-secondary" onclick="generateNewBuildChallenge()">New Challenge</button>
        </div>
      </div>

      <!-- Step 1: Define Intervals -->
      <div class="interval-selector">
        <h3>Step 1: Define Intervals</h3>
        
        <div class="interval-builder">
          <button class="bracket-toggle" id="left-bracket" onclick="toggleBracket('left')">(</button>
          
          <div class="infinity-toggle">
            <input type="checkbox" id="left-infinity" class="infinity-checkbox" onchange="toggleInfinity('left')">
            <label for="left-infinity" class="infinity-label">-∞</label>
          </div>
          
          <input type="text" id="left-value" class="interval-input" placeholder="-2" value="-2">
          
          <span class="comma">,</span>
          
          <input type="text" id="right-value" class="interval-input" placeholder="2" value="2">
          
          <div class="infinity-toggle">
            <input type="checkbox" id="right-infinity" class="infinity-checkbox" onchange="toggleInfinity('right')">
            <label for="right-infinity" class="infinity-label">+∞</label>
          </div>
          
          <button class="bracket-toggle" id="right-bracket" onclick="toggleBracket('right')">)</button>
          
          <button class="add-interval-btn" onclick="addCustomInterval()">Add Interval</button>
        </div>
        
        <div class="preset-intervals">
          <div class="preset-label">Quick Presets:</div>
          <button class="preset-btn" onclick="setPresetInterval('ninf-0')">(-∞, 0)</button>
          <button class="preset-btn" onclick="setPresetInterval('0-inf')">(0, ∞)</button>
          <button class="preset-btn" onclick="setPresetInterval('full')">(-∞, ∞)</button>
          <button class="preset-btn" onclick="setPresetInterval('-1-1')">[-1, 1]</button>
        </div>
      </div>

      <!-- Step 2: Visual Behavior Selection -->
      <div class="visual-behaviors">
        <h3>Step 2: Assign Behaviors (Select interval first, then click visual cards)</h3>
        
        <div class="visual-grid" id="behavior-cards">
          <!-- Visual behavior cards will be generated here -->
        </div>
      </div>

      <!-- Your Segments Display -->
      <div class="segments-display">
        <h3>Your Segments</h3>
        <div class="segments-list" id="segments-list">
          <div class="placeholder-text">No segments yet. Add intervals above.</div>
        </div>
      </div>

      <!-- Step 3: Visual Connections -->
      <div class="connections-panel">
        <h3>Step 3: Connect Segments (Select two segments, then choose connection)</h3>
        
        <div class="connection-cards" id="connection-cards">
          <!-- Visual connection cards will be generated here -->
        </div>
        
        <div class="asymptote-controls">
          <select id="asymptote-type" style="padding: 0.5rem; border: 2px solid var(--border); border-radius: 6px;">
            <option value="vertical">Vertical (x =)</option>
            <option value="horizontal">Horizontal (y =)</option>
          </select>
          <input type="number" id="asymptote-value" placeholder="0" value="0" style="width: 100px; padding: 0.5rem; border: 2px solid var(--border); border-radius: 6px;">
          <button class="btn btn-secondary" onclick="addAsymptote()">Add Asymptote</button>
        </div>
        
        <div class="asymptote-list" id="asymptote-list"></div>
      </div>

      <!-- Graph Display -->
      <div class="graph-display">
        <h3>Your Function</h3>
        <canvas class="graph-canvas" id="build-graph"></canvas>
        <div class="controls">
          <button class="btn btn-primary" onclick="checkBuildAnswer()">Check with AI</button>
          <button class="btn btn-secondary" onclick="clearAll()">Clear All</button>
        </div>
        <div class="feedback" id="build-feedback"></div>
      </div>
    </div>
  </div>

  <script>
    // Global state
    const state = {
      readProblem: null,
      readSequence: [],
      buildChallenge: null,
      segments: [],
      selectedSegment: null,
      selectedSegments: [],
      connections: [],
      asymptotes: [],
      draggedCard: null,
      hintCount: 0,
      exampleClickCount: {},
      intervalBuilder: {
        leftBracket: 'open',
        rightBracket: 'open',
        leftInfinity: false,
        rightInfinity: false
      }
    };

    // Word behavior types for Read tab
    const behaviorTypes = [
      { id: 'increasing', label: 'Increasing' },
      { id: 'decreasing', label: 'Decreasing' },
      { id: 'constant', label: 'Constant' },
      { id: 'concave-up', label: 'Concave Up' },
      { id: 'concave-down', label: 'Concave Down' },
      { id: 'linear', label: 'Linear' },
      { id: 'inflection', label: 'Inflection Point' },
      { id: 'corner', label: 'Corner' },
      { id: 'cusp', label: 'Cusp' },
      { id: 'jump-up', label: 'Jump Up' },
      { id: 'jump-down', label: 'Jump Down' },
      { id: 'vertical-asymptote', label: 'Vertical Asymptote' },
      { id: 'horizontal-asymptote', label: 'Horizontal Asymptote' }
    ];

    // Visual behavior types for Build tab (no labels)
    const visualBehaviors = [
      { id: 'increasing', type: 'direction' },
      { id: 'decreasing', type: 'direction' },
      { id: 'constant', type: 'direction' },
      { id: 'concave-up', type: 'curvature' },
      { id: 'concave-down', type: 'curvature' },
      { id: 'linear', type: 'curvature' },
      { id: 'inc-cup', type: 'combined' },
      { id: 'inc-cdown', type: 'combined' },
      { id: 'dec-cup', type: 'combined' },
      { id: 'dec-cdown', type: 'combined' }
    ];

    // Connection types for Build tab
    const connectionTypes = [
      { id: 'inflection', label: 'Inflection' },
      { id: 'jump', label: 'Jump' },
      { id: 'corner', label: 'Corner' },
      { id: 'cusp', label: 'Cusp' },
      { id: 'smooth', label: 'Smooth' }
    ];

    // Drawing functions
    function drawIncreasing(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.lineTo(w - 10, 10);
      ctx.stroke();
    }

    function drawDecreasing(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.lineTo(w - 10, h - 10);
      ctx.stroke();
    }

    function drawConstant(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h/2);
      ctx.lineTo(w - 10, h/2);
      ctx.stroke();
    }

    function drawConcaveUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h/2);
      ctx.quadraticCurveTo(w/2, h - 10, w - 10, h/2);
      ctx.stroke();
    }

    function drawConcaveDown(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h/2);
      ctx.quadraticCurveTo(w/2, 10, w - 10, h/2);
      ctx.stroke();
    }

    function drawLinear(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h * 0.6);
      ctx.lineTo(w - 10, h * 0.4);
      ctx.stroke();
    }

    function drawIncreasingConcaveUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.quadraticCurveTo(w/3, h - 5, w - 10, 10);
      ctx.stroke();
    }

    function drawIncreasingConcaveDown(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.quadraticCurveTo(w*2/3, 5, w - 10, 10);
      ctx.stroke();
    }

    function drawDecreasingConcaveUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.quadraticCurveTo(w/2, h - 15, w - 10, h - 10);
      ctx.stroke();
    }

    function drawDecreasingConcaveDown(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.quadraticCurveTo(w/2, 15, w - 10, h - 10);
      ctx.stroke();
    }

    function drawCorner(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.lineTo(w/2, 10);
      ctx.lineTo(w - 10, h - 10);
      ctx.stroke();
      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.arc(w/2, 10, 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawCusp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h/2);
      ctx.quadraticCurveTo(w/2 - 10, 10, w/2, 10);
      ctx.quadraticCurveTo(w/2 + 10, 10, w - 10, h/2);
      ctx.stroke();
      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.arc(w/2, 10, 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawInflection(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h - 10);
      ctx.bezierCurveTo(w/3, h - 10, w*2/3, 10, w - 10, 10);
      ctx.stroke();
      ctx.fillStyle = '#f59e0b';
      ctx.beginPath();
      ctx.arc(w/2, h/2, 4, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawJumpUp(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h * 0.7);
      ctx.lineTo(w/2 - 5, h * 0.7);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 - 5, h * 0.7, 4, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(w/2 + 5, h * 0.3);
      ctx.lineTo(w - 10, h * 0.3);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(w/2 + 5, h * 0.3, 4, 0, 2 * Math.PI);
      ctx.fillStyle = '#0f766e';
      ctx.fill();
    }

    function drawSmooth(ctx, w, h) {
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(10, h * 0.7);
      ctx.bezierCurveTo(w/3, h * 0.7, w*2/3, h * 0.3, w - 10, h * 0.3);
      ctx.stroke();
    }

    // Initialize examples
    function drawExamples() {
      const examples = [
        { id: 'ex-inc', func: drawIncreasing },
        { id: 'ex-dec', func: drawDecreasing },
        { id: 'ex-cup', func: drawConcaveUp },
        { id: 'ex-cdown', func: drawConcaveDown },
        { id: 'ex-corner', func: drawCorner },
        { id: 'ex-cusp', func: drawCusp },
        { id: 'ex-inflect', func: drawInflection },
        { id: 'ex-jump', func: drawJumpUp }
      ];

      examples.forEach(ex => {
        const canvas = document.getElementById(ex.id);
        if (canvas) {
          const ctx = canvas.getContext('2d');
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ex.func(ctx, canvas.width, canvas.height);
        }
      });
    }

    // Initialize visual behavior cards for Build tab
    function initializeVisualBehaviors() {
      const container = document.getElementById('behavior-cards');
      container.innerHTML = '';
      
      visualBehaviors.forEach(behavior => {
        const card = document.createElement('div');
        card.className = 'visual-card';
        card.dataset.id = behavior.id;
        card.dataset.type = behavior.type;
        card.onclick = () => selectVisualBehavior(behavior.id, behavior.type);
        
        const canvas = document.createElement('canvas');
        card.appendChild(canvas);
        container.appendChild(card);
        
        // Draw the behavior
        setTimeout(() => {
          const ctx = canvas.getContext('2d');
          canvas.width = 80;
          canvas.height = 80;
          
          switch(behavior.id) {
            case 'increasing': drawIncreasing(ctx, 80, 80); break;
            case 'decreasing': drawDecreasing(ctx, 80, 80); break;
            case 'constant': drawConstant(ctx, 80, 80); break;
            case 'concave-up': drawConcaveUp(ctx, 80, 80); break;
            case 'concave-down': drawConcaveDown(ctx, 80, 80); break;
            case 'linear': drawLinear(ctx, 80, 80); break;
            case 'inc-cup': drawIncreasingConcaveUp(ctx, 80, 80); break;
            case 'inc-cdown': drawIncreasingConcaveDown(ctx, 80, 80); break;
            case 'dec-cup': drawDecreasingConcaveUp(ctx, 80, 80); break;
            case 'dec-cdown': drawDecreasingConcaveDown(ctx, 80, 80); break;
          }
        }, 10);
      });
    }

    // Initialize connection cards for Build tab
    function initializeConnectionCards() {
      const container = document.getElementById('connection-cards');
      container.innerHTML = '';
      
      connectionTypes.forEach(conn => {
        const card = document.createElement('button');
        card.className = 'connection-card';
        card.onclick = () => applyConnection(conn.id);
        
        const canvas = document.createElement('canvas');
        card.appendChild(canvas);
        container.appendChild(card);
        
        // Draw the connection type
        setTimeout(() => {
          const ctx = canvas.getContext('2d');
          canvas.width = 100;
          canvas.height = 100;
          
          switch(conn.id) {
            case 'inflection': drawInflection(ctx, 100, 100); break;
            case 'jump': drawJumpUp(ctx, 100, 100); break;
            case 'corner': drawCorner(ctx, 100, 100); break;
            case 'cusp': drawCusp(ctx, 100, 100); break;
            case 'smooth': drawSmooth(ctx, 100, 100); break;
          }
        }, 10);
      });
    }

    // Toggle example info
    function toggleExampleInfo(card) {
      const id = card.querySelector('.example-canvas').id;
      if (!state.exampleClickCount[id]) state.exampleClickCount[id] = 0;
      
      state.exampleClickCount[id]++;
      
      card.classList.remove('show-math', 'show-interval');
      
      if (state.exampleClickCount[id] % 3 === 1) {
        card.classList.add('show-math');
      } else if (state.exampleClickCount[id] % 3 === 2) {
        card.classList.add('show-interval');
      }
    }

    // READ TAB FUNCTIONS
    function createWordCard(type) {
      const card = document.createElement('div');
      card.className = 'word-card';
      card.dataset.type = type.id;
      card.draggable = true;
      card.textContent = type.label;
      
      card.addEventListener('click', () => {
        if (card.parentElement.classList.contains('sequence-container')) {
          const idx = state.readSequence.indexOf(type.id);
          if (idx > -1) state.readSequence.splice(idx, 1);
          card.remove();
          
          const container = document.getElementById('read-sequence');
          if (container.children.length === 0) {
            const placeholder = document.createElement('div');
            placeholder.className = 'placeholder-text';
            placeholder.textContent = 'Drag word cards here or click selected cards to remove';
            container.appendChild(placeholder);
          }
        } else {
          card.classList.toggle('selected');
        }
      });
      
      card.addEventListener('dragstart', handleDragStart);
      card.addEventListener('dragend', handleDragEnd);
      
      return card;
    }

    function handleDragStart(e) {
      const card = e.target;
      state.draggedCard = {
        type: card.dataset.type,
        element: card,
        fromSequence: card.parentElement.classList.contains('sequence-container')
      };
      card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragEnd(e) {
      e.target.classList.remove('dragging');
      state.draggedCard = null;
    }

    function handleDragOver(e) {
      if (e.preventDefault) {
        e.preventDefault();
      }
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDragEnter(e) {
      if (e.target.classList.contains('sequence-container')) {
        e.target.classList.add('drag-over');
      }
    }

    function handleDragLeave(e) {
      if (e.target.classList.contains('sequence-container')) {
        e.target.classList.remove('drag-over');
      }
    }

    function handleDrop(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      
      const container = document.getElementById('read-sequence');
      container.classList.remove('drag-over');
      
      if (!state.draggedCard) return false;
      
      const placeholder = container.querySelector('.placeholder-text');
      if (placeholder) {
        placeholder.remove();
      }
      
      if (state.draggedCard.fromSequence) {
        const idx = state.readSequence.indexOf(state.draggedCard.type);
        if (idx > -1) state.readSequence.splice(idx, 1);
        state.draggedCard.element.remove();
      }
      
      const typeObj = behaviorTypes.find(t => t.id === state.draggedCard.type);
      if (typeObj) {
        const newCard = createWordCard(typeObj);
        container.appendChild(newCard);
        state.readSequence.push(state.draggedCard.type);
      }
      
      return false;
    }

    function initializeReadTab() {
      const container = document.getElementById('read-cards');
      container.innerHTML = '';
      
      behaviorTypes.forEach(type => {
        const card = createWordCard(type);
        container.appendChild(card);
      });
      
      const sequence = document.getElementById('read-sequence');
      sequence.addEventListener('dragover', handleDragOver);
      sequence.addEventListener('drop', handleDrop);
      sequence.addEventListener('dragenter', handleDragEnter);
      sequence.addEventListener('dragleave', handleDragLeave);
      
      generateNewReadProblem();
    }

    const readProblems = [
      { 
        sequence: ['increasing', 'concave-up'], 
        intervals: [['(-∞', '∞)'], ['(-∞', '∞)']],
        description: 'Increasing and concave up everywhere' 
      },
      { 
        sequence: ['decreasing', 'concave-down', 'inflection', 'decreasing', 'concave-up'], 
        intervals: [['(-∞', '0)'], ['(-∞', '0)'], ['x=0'], ['(0', '∞)'], ['(0', '∞)']],
        description: 'Decreasing with inflection at x=0' 
      },
      { 
        sequence: ['constant', 'jump-up', 'increasing'], 
        intervals: [['(-∞', '0)'], ['x=0'], ['(0', '∞)']],
        description: 'Constant then jump up, then increasing' 
      }
    ];

    function generateNewReadProblem() {
      state.readProblem = readProblems[Math.floor(Math.random() * readProblems.length)];
      state.hintCount = 0;
      drawReadGraph();
      clearReadSequence();
    }

    function drawReadGraph() {
      const canvas = document.getElementById('read-graph');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth || 800;
      canvas.height = 400;
      
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      drawGrid(ctx, w, h);
      
      ctx.save();
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      
      const problem = state.readProblem;
      
      if (problem.description.includes('everywhere')) {
        ctx.beginPath();
        ctx.moveTo(50, h - 50);
        for (let x = 50; x < w - 50; x += 5) {
          const t = (x - 50) / (w - 100);
          const y = h - 50 - 200 * Math.pow(t, 2);
          ctx.lineTo(x, Math.max(50, y));
        }
        ctx.stroke();
      } else if (problem.description.includes('inflection')) {
        ctx.beginPath();
        for (let x = 50; x < w - 50; x += 5) {
          const t = (x - w/2) / 150;
          const y = h/2 - 100 * Math.tanh(t);
          if (x === 50) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.stroke();
        ctx.fillStyle = '#f59e0b';
        ctx.beginPath();
        ctx.arc(w/2, h/2, 6, 0, 2 * Math.PI);
        ctx.fill();
      } else if (problem.description.includes('jump')) {
        ctx.beginPath();
        ctx.moveTo(50, h * 0.6);
        ctx.lineTo(w/2 - 10, h * 0.6);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(w/2 - 10, h * 0.6, 5, 0, 2 * Math.PI);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(w/2 + 10, h * 0.4, 5, 0, 2 * Math.PI);
        ctx.fillStyle = '#0f766e';
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(w/2 + 10, h * 0.4);
        ctx.lineTo(w - 50, h * 0.2);
        ctx.stroke();
      }
      
      ctx.restore();
    }

    function clearReadSequence() {
      const container = document.getElementById('read-sequence');
      container.innerHTML = '<div class="placeholder-text">Drag word cards here or click selected cards to remove</div>';
      state.readSequence = [];
      document.getElementById('read-feedback').classList.remove('show');
      document.getElementById('sentence-display').innerHTML = '';
    }

    function getHint() {
      const feedback = document.getElementById('read-feedback');
      state.hintCount++;
      
      if (state.hintCount === 1) {
        feedback.className = 'feedback info show';
        feedback.textContent = `Hint: Look for ${state.readProblem.sequence.length} behaviors in the graph.`;
      } else if (state.hintCount === 2) {
        feedback.className = 'feedback info show';
        feedback.textContent = `Hint: The first behavior is "${state.readProblem.sequence[0].replace(/-/g, ' ')}".`;
      } else {
        feedback.className = 'feedback info show';
        const labels = state.readProblem.sequence.map(s => 
          behaviorTypes.find(t => t.id === s)?.label || s
        );
        feedback.textContent = `Answer: ${labels.join(' → ')}`;
      }
    }

    function checkReadAnswer() {
      const feedback = document.getElementById('read-feedback');
      const sentenceDisplay = document.getElementById('sentence-display');
      
      if (state.readSequence.length === 0) {
        feedback.className = 'feedback error show';
        feedback.textContent = 'Please add behavior cards first.';
        return;
      }
      
      const correct = JSON.stringify(state.readSequence) === JSON.stringify(state.readProblem.sequence);
      
      if (correct) {
        feedback.className = 'feedback success show';
        feedback.textContent = 'Excellent! You correctly identified all behaviors!';
        
        const sentence = generateSentence(state.readProblem);
        sentenceDisplay.className = 'sentence-display';
        sentenceDisplay.innerHTML = `<strong>Complete Description:</strong><br>${sentence}`;
        
        const cards = document.querySelectorAll('#read-sequence .word-card');
        cards.forEach((card, i) => {
          setTimeout(() => {
            card.style.transform = 'scale(1.1)';
            card.style.background = 'linear-gradient(135deg, #10b981, #0f766e)';
            card.style.color = 'white';
          }, i * 100);
        });
      } else {
        feedback.className = 'feedback error show';
        const missing = state.readProblem.sequence.length - state.readSequence.length;
        if (missing > 0) {
          feedback.textContent = `You're missing ${missing} behavior(s).`;
        } else if (missing < 0) {
          feedback.textContent = `Too many behaviors. You have ${-missing} extra card(s).`;
        } else {
          feedback.textContent = 'Not quite right. Check the order.';
        }
        sentenceDisplay.innerHTML = '';
      }
    }

    function generateSentence(problem) {
      let sentence = "The function ";
      const behaviors = problem.sequence;
      const intervals = problem.intervals;
      
      behaviors.forEach((behavior, i) => {
        if (i > 0) sentence += ", ";
        
        const interval = intervals[i];
        const intervalStr = interval ? interval.join(', ') : "";
        
        const typeObj = behaviorTypes.find(t => t.id === behavior);
        const label = typeObj ? typeObj.label.toLowerCase() : behavior;
        
        if (behavior === 'inflection') {
          sentence += `has an inflection point at ${intervalStr}`;
        } else if (behavior.includes('jump')) {
          sentence += `has a ${label} discontinuity at ${intervalStr}`;
        } else if (behavior.includes('asymptote')) {
          sentence += `approaches a ${label} at ${intervalStr}`;
        } else {
          sentence += `is ${label} on ${intervalStr}`;
        }
      });
      
      sentence += ".";
      return sentence;
    }

    // BUILD TAB FUNCTIONS
    function toggleBracket(side) {
      const btn = document.getElementById(`${side}-bracket`);
      if (side === 'left') {
        state.intervalBuilder.leftBracket = state.intervalBuilder.leftBracket === 'open' ? 'closed' : 'open';
        btn.textContent = state.intervalBuilder.leftBracket === 'open' ? '(' : '[';
      } else {
        state.intervalBuilder.rightBracket = state.intervalBuilder.rightBracket === 'open' ? 'closed' : 'open';
        btn.textContent = state.intervalBuilder.rightBracket === 'open' ? ')' : ']';
      }
      btn.classList.toggle('closed');
    }

    function toggleInfinity(side) {
      const checkbox = document.getElementById(`${side}-infinity`);
      const input = document.getElementById(`${side}-value`);
      
      if (side === 'left') {
        state.intervalBuilder.leftInfinity = checkbox.checked;
        input.disabled = checkbox.checked;
        input.style.opacity = checkbox.checked ? '0.3' : '1';
        if (checkbox.checked) {
          state.intervalBuilder.leftBracket = 'open';
          const btn = document.getElementById('left-bracket');
          btn.textContent = '(';
          btn.classList.remove('closed');
        }
      } else {
        state.intervalBuilder.rightInfinity = checkbox.checked;
        input.disabled = checkbox.checked;
        input.style.opacity = checkbox.checked ? '0.3' : '1';
        if (checkbox.checked) {
          state.intervalBuilder.rightBracket = 'open';
          const btn = document.getElementById('right-bracket');
          btn.textContent = ')';
          btn.classList.remove('closed');
        }
      }
    }

    function addCustomInterval() {
      const leftValue = state.intervalBuilder.leftInfinity ? -Infinity : parseFloat(document.getElementById('left-value').value);
      const rightValue = state.intervalBuilder.rightInfinity ? Infinity : parseFloat(document.getElementById('right-value').value);
      
      if (!state.intervalBuilder.leftInfinity && !state.intervalBuilder.rightInfinity) {
        if (isNaN(leftValue) || isNaN(rightValue)) {
          alert('Please enter valid numbers');
          return;
        }
        if (leftValue >= rightValue) {
          alert('Left value must be less than right value');
          return;
        }
      }
      
      const leftBracket = state.intervalBuilder.leftBracket === 'open' ? '(' : '[';
      const rightBracket = state.intervalBuilder.rightBracket === 'open' ? ')' : ']';
      const leftText = state.intervalBuilder.leftInfinity ? '-∞' : leftValue;
      const rightText = state.intervalBuilder.rightInfinity ? '∞' : rightValue;
      
      const intervalText = `${leftBracket}${leftText}, ${rightText}${rightBracket}`;
      
      const segment = {
        id: 'seg-' + Date.now(),
        interval: intervalText,
        start: leftValue,
        end: rightValue,
        direction: null,
        curvature: null
      };
      
      state.segments.push(segment);
      renderSegments();
      updateBuildGraph();
    }

    function setPresetInterval(preset) {
      const leftInfinity = document.getElementById('left-infinity');
      const rightInfinity = document.getElementById('right-infinity');
      const leftValue = document.getElementById('left-value');
      const rightValue = document.getElementById('right-value');
      
      switch(preset) {
        case 'ninf-0':
          leftInfinity.checked = true;
          rightInfinity.checked = false;
          rightValue.value = '0';
          toggleInfinity('left');
          state.intervalBuilder.rightInfinity = false;
          break;
        case '0-inf':
          leftInfinity.checked = false;
          rightInfinity.checked = true;
          leftValue.value = '0';
          toggleInfinity('right');
          state.intervalBuilder.leftInfinity = false;
          break;
        case 'full':
          leftInfinity.checked = true;
          rightInfinity.checked = true;
          toggleInfinity('left');
          toggleInfinity('right');
          break;
        case '-1-1':
          leftInfinity.checked = false;
          rightInfinity.checked = false;
          leftValue.value = '-1';
          rightValue.value = '1';
          state.intervalBuilder.leftBracket = 'closed';
          state.intervalBuilder.rightBracket = 'closed';
          document.getElementById('left-bracket').textContent = '[';
          document.getElementById('left-bracket').classList.add('closed');
          document.getElementById('right-bracket').textContent = ']';
          document.getElementById('right-bracket').classList.add('closed');
          state.intervalBuilder.leftInfinity = false;
          state.intervalBuilder.rightInfinity = false;
          leftValue.disabled = false;
          rightValue.disabled = false;
          leftValue.style.opacity = '1';
          rightValue.style.opacity = '1';
          break;
      }
      
      addCustomInterval();
    }

    function selectVisualBehavior(behaviorId, type) {
      if (!state.selectedSegment) {
        alert('Please select a segment first');
        return;
      }
      
      const segment = state.segments.find(s => s.id === state.selectedSegment);
      if (!segment) return;
      
      // Handle combined behaviors
      if (type === 'combined') {
        switch(behaviorId) {
          case 'inc-cup':
            segment.direction = 'increasing';
            segment.curvature = 'concave-up';
            break;
          case 'inc-cdown':
            segment.direction = 'increasing';
            segment.curvature = 'concave-down';
            break;
          case 'dec-cup':
            segment.direction = 'decreasing';
            segment.curvature = 'concave-up';
            break;
          case 'dec-cdown':
            segment.direction = 'decreasing';
            segment.curvature = 'concave-down';
            break;
        }
      } else if (type === 'direction') {
        segment.direction = behaviorId;
      } else if (type === 'curvature') {
        segment.curvature = behaviorId;
      }
      
      // Update visual cards
      document.querySelectorAll('.visual-card').forEach(card => {
        if (card.dataset.type === 'direction') {
          card.classList.toggle('active', segment.direction === card.dataset.id);
        } else if (card.dataset.type === 'curvature') {
          card.classList.toggle('active', segment.curvature === card.dataset.id);
        } else if (card.dataset.type === 'combined') {
          const isActive = (
            (card.dataset.id === 'inc-cup' && segment.direction === 'increasing' && segment.curvature === 'concave-up') ||
            (card.dataset.id === 'inc-cdown' && segment.direction === 'increasing' && segment.curvature === 'concave-down') ||
            (card.dataset.id === 'dec-cup' && segment.direction === 'decreasing' && segment.curvature === 'concave-up') ||
            (card.dataset.id === 'dec-cdown' && segment.direction === 'decreasing' && segment.curvature === 'concave-down')
          );
          card.classList.toggle('active', isActive);
        }
      });
      
      renderSegments();
      updateBuildGraph();
    }

    function selectSegment(id) {
      const wasSelected = state.selectedSegment === id;
      
      // For single selection (behavior assignment)
      state.selectedSegment = wasSelected ? null : id;
      
      // For multiple selection (connections)
      const item = document.getElementById(id);
      if (item.classList.contains('selected')) {
        item.classList.remove('selected');
        state.selectedSegments = state.selectedSegments.filter(s => s !== id);
      } else {
        item.classList.add('selected');
        state.selectedSegments.push(id);
      }
      
      // Update visual cards
      if (!wasSelected) {
        const segment = state.segments.find(s => s.id === id);
        document.querySelectorAll('.visual-card').forEach(card => {
          if (card.dataset.type === 'direction') {
            card.classList.toggle('active', segment.direction === card.dataset.id);
          } else if (card.dataset.type === 'curvature') {
            card.classList.toggle('active', segment.curvature === card.dataset.id);
          } else if (card.dataset.type === 'combined') {
            const isActive = (
              (card.dataset.id === 'inc-cup' && segment.direction === 'increasing' && segment.curvature === 'concave-up') ||
              (card.dataset.id === 'inc-cdown' && segment.direction === 'increasing' && segment.curvature === 'concave-down') ||
              (card.dataset.id === 'dec-cup' && segment.direction === 'decreasing' && segment.curvature === 'concave-up') ||
              (card.dataset.id === 'dec-cdown' && segment.direction === 'decreasing' && segment.curvature === 'concave-down')
            );
            card.classList.toggle('active', isActive);
          }
        });
      } else {
        document.querySelectorAll('.visual-card').forEach(card => {
          card.classList.remove('active');
        });
      }
    }

    function removeSegment(id) {
      state.segments = state.segments.filter(s => s.id !== id);
      state.selectedSegments = state.selectedSegments.filter(s => s !== id);
      if (state.selectedSegment === id) state.selectedSegment = null;
      renderSegments();
      updateBuildGraph();
    }

    function renderSegments() {
      const container = document.getElementById('segments-list');
      container.innerHTML = '';
      
      if (state.segments.length === 0) {
        container.innerHTML = '<div class="placeholder-text">No segments yet. Add intervals above.</div>';
        return;
      }
      
      state.segments.forEach(segment => {
        const item = document.createElement('div');
        item.className = 'segment-item';
        if (state.selectedSegments.includes(segment.id)) {
          item.classList.add('selected');
        }
        item.id = segment.id;
        item.onclick = () => selectSegment(segment.id);
        
        const canvas = document.createElement('canvas');
        const label = document.createElement('div');
        label.className = 'segment-label';
        label.textContent = segment.interval;
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-segment';
        removeBtn.textContent = '×';
        removeBtn.onclick = (e) => {
          e.stopPropagation();
          removeSegment(segment.id);
        };
        
        item.appendChild(canvas);
        item.appendChild(label);
        item.appendChild(removeBtn);
        container.appendChild(item);
        
        setTimeout(() => {
          drawSegmentPreview(canvas, segment);
        }, 10);
      });
    }

    function drawSegmentPreview(canvas, segment) {
      const ctx = canvas.getContext('2d');
      canvas.width = 150;
      canvas.height = 60;
      
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      const w = canvas.width;
      const h = canvas.height;
      
      if (segment.direction === 'constant') {
        ctx.moveTo(10, h/2);
        ctx.lineTo(w - 10, h/2);
      } else if (segment.direction === 'increasing') {
        if (segment.curvature === 'concave-up') {
          ctx.moveTo(10, h - 10);
          ctx.quadraticCurveTo(w/3, h - 5, w - 10, 10);
        } else if (segment.curvature === 'concave-down') {
          ctx.moveTo(10, h - 10);
          ctx.quadraticCurveTo(w*2/3, 5, w - 10, 10);
        } else {
          ctx.moveTo(10, h - 10);
          ctx.lineTo(w - 10, 10);
        }
      } else if (segment.direction === 'decreasing') {
        if (segment.curvature === 'concave-up') {
          ctx.moveTo(10, 10);
          ctx.quadraticCurveTo(w/2, h - 15, w - 10, h - 10);
        } else if (segment.curvature === 'concave-down') {
          ctx.moveTo(10, 10);
          ctx.quadraticCurveTo(w/2, 15, w - 10, h - 10);
        } else {
          ctx.moveTo(10, 10);
          ctx.lineTo(w - 10, h - 10);
        }
      } else {
        // No direction set - show generic based on curvature
        if (segment.curvature === 'concave-up') {
          ctx.moveTo(10, h/2);
          ctx.quadraticCurveTo(w/2, h - 10, w - 10, h/2);
        } else if (segment.curvature === 'concave-down') {
          ctx.moveTo(10, h/2);
          ctx.quadraticCurveTo(w/2, 10, w - 10, h/2);
        } else {
          ctx.moveTo(10, h/2);
          ctx.lineTo(w - 10, h/2);
        }
      }
      
      ctx.stroke();
    }

    function applyConnection(connectionType) {
      if (state.selectedSegments.length !== 2) {
        alert('Please select exactly 2 segments');
        return;
      }
      
      const seg1 = state.segments.find(s => s.id === state.selectedSegments[0]);
      const seg2 = state.segments.find(s => s.id === state.selectedSegments[1]);
      
      // Check conditions for specific connections
      if (connectionType === 'inflection') {
        const adjacent = Math.abs(seg1.end - seg2.start) < 0.1 || Math.abs(seg2.end - seg1.start) < 0.1;
        if (!adjacent) {
          alert('Segments must be adjacent for inflection point');
          return;
        }
        
        if (!seg1.curvature || !seg2.curvature || seg1.curvature === seg2.curvature) {
          alert('Segments must have opposite concavity for inflection point');
          return;
        }
      }
      
      const connectionPoint = (Math.max(seg1.start, seg2.start) + Math.min(seg1.end, seg2.end)) / 2;
      
      state.connections.push({
        type: connectionType,
        from: seg1.id,
        to: seg2.id,
        at: connectionPoint
      });
      
      clearSelection();
      updateBuildGraph();
    }

    function clearSelection() {
      state.selectedSegments = [];
      document.querySelectorAll('.segment-item').forEach(item => {
        item.classList.remove('selected');
      });
    }

    function addAsymptote() {
      const type = document.getElementById('asymptote-type').value;
      const value = parseFloat(document.getElementById('asymptote-value').value);
      
      if (isNaN(value)) {
        alert('Please enter a valid number');
        return;
      }
      
      state.asymptotes.push({ type, value, id: 'asym-' + Date.now() });
      renderAsymptotes();
      updateBuildGraph();
    }

    function removeAsymptote(id) {
      state.asymptotes = state.asymptotes.filter(a => a.id !== id);
      renderAsymptotes();
      updateBuildGraph();
    }

    function renderAsymptotes() {
      const container = document.getElementById('asymptote-list');
      container.innerHTML = '';
      
      state.asymptotes.forEach(asym => {
        const tag = document.createElement('div');
        tag.className = 'asymptote-tag';
        tag.innerHTML = `
          <span>${asym.type === 'vertical' ? 'x' : 'y'} = ${asym.value}</span>
          <button onclick="removeAsymptote('${asym.id}')">×</button>
        `;
        container.appendChild(tag);
      });
    }

    function updateBuildGraph() {
      const canvas = document.getElementById('build-graph');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      canvas.width = canvas.offsetWidth;
      canvas.height = 400;
      
      const w = canvas.width;
      const h = canvas.height;
      
      ctx.clearRect(0, 0, w, h);
      drawGrid(ctx, w, h);
      
      // Draw asymptotes
      ctx.save();
      ctx.strokeStyle = '#dc2626';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      
      state.asymptotes.forEach(asym => {
        ctx.beginPath();
        if (asym.type === 'vertical') {
          const x = w/2 + asym.value * 50;
          ctx.moveTo(x, 0);
          ctx.lineTo(x, h);
        } else {
          const y = h/2 - asym.value * 50;
          ctx.moveTo(0, y);
          ctx.lineTo(w, y);
        }
        ctx.stroke();
      });
      
      ctx.restore();
      
      // Draw segments
      ctx.save();
      ctx.strokeStyle = '#0f766e';
      ctx.lineWidth = 3;
      
      state.segments.forEach(segment => {
        const startX = segment.start === -Infinity ? 0 : w/2 + segment.start * 50;
        const endX = segment.end === Infinity ? w : w/2 + segment.end * 50;
        
        ctx.beginPath();
        
        let startY = h/2;
        let endY = h/2;
        
        if (segment.direction === 'increasing') {
          startY = h/2 + 30;
          endY = h/2 - 30;
        } else if (segment.direction === 'decreasing') {
          startY = h/2 - 30;
          endY = h/2 + 30;
        }
        
        if (segment.direction === 'constant') {
          ctx.moveTo(startX, h/2);
          ctx.lineTo(endX, h/2);
        } else if (segment.curvature === 'concave-up' || segment.curvature === 'concave-down') {
          ctx.moveTo(startX, startY);
          const midX = (startX + endX) / 2;
          const midY = segment.curvature === 'concave-up' ? 
            (startY + endY) / 2 + 20 : 
            (startY + endY) / 2 - 20;
          ctx.quadraticCurveTo(midX, midY, endX, endY);
        } else {
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
        }
        
        ctx.stroke();
      });
      
      // Draw connections
      state.connections.forEach(conn => {
        const x = w/2 + conn.at * 50;
        
        if (conn.type === 'inflection') {
          ctx.fillStyle = '#f59e0b';
          ctx.beginPath();
          ctx.arc(x, h/2, 6, 0, 2 * Math.PI);
          ctx.fill();
        } else if (conn.type === 'jump') {
          ctx.beginPath();
          ctx.arc(x - 5, h/2 + 20, 4, 0, 2 * Math.PI);
          ctx.fillStyle = 'white';
          ctx.fill();
          ctx.strokeStyle = '#0f766e';
          ctx.stroke();
          
          ctx.beginPath();
          ctx.arc(x + 5, h/2 - 20, 4, 0, 2 * Math.PI);
          ctx.fillStyle = '#0f766e';
          ctx.fill();
        } else if (conn.type === 'corner') {
          ctx.fillStyle = '#f59e0b';
          ctx.beginPath();
          ctx.moveTo(x - 5, h/2 + 5);
          ctx.lineTo(x, h/2 - 5);
          ctx.lineTo(x + 5, h/2 + 5);
          ctx.closePath();
          ctx.fill();
        } else if (conn.type === 'cusp') {
          ctx.fillStyle = '#f59e0b';
          ctx.beginPath();
          ctx.arc(x, h/2, 6, 0, Math.PI);
          ctx.fill();
        }
      });
      
      ctx.restore();
    }

    function drawGrid(ctx, w, h) {
      ctx.strokeStyle = '#e8e8e8';
      ctx.lineWidth = 1;
      
      for (let x = 0; x <= w; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }
      
      for (let y = 0; y <= h; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
      
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(w/2, 0);
      ctx.lineTo(w/2, h);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, h/2);
      ctx.lineTo(w, h/2);
      ctx.stroke();
    }

    function clearAll() {
      state.segments = [];
      state.connections = [];
      state.asymptotes = [];
      state.selectedSegment = null;
      state.selectedSegments = [];
      renderSegments();
      renderAsymptotes();
      updateBuildGraph();
      document.querySelectorAll('.visual-card').forEach(card => {
        card.classList.remove('active');
      });
    }

    const buildChallenges = [
      "A function that is increasing and concave up",
      "A function that is decreasing and concave up, then increasing and concave up",
      "A function that is constant, has a jump up discontinuity, then is increasing",
      "A function that is increasing concave up, has an inflection point, then is increasing concave down",
      "A function with a corner at x = 0",
      "A function with a cusp at x = 1",
      "A function with a vertical asymptote at x = 0"
    ];

    function generateNewBuildChallenge() {
      state.buildChallenge = buildChallenges[Math.floor(Math.random() * buildChallenges.length)];
      document.getElementById('build-challenge').textContent = state.buildChallenge;
      clearAll();
    }

    async function checkBuildAnswer() {
      const feedback = document.getElementById('build-feedback');
      
      if (state.segments.length === 0) {
        feedback.className = 'feedback error show';
        feedback.textContent = 'Please create at least one segment';
        return;
      }
      
      let description = "Student created: ";
      state.segments.forEach((seg, i) => {
        if (i > 0) description += ", ";
        description += `${seg.interval}: `;
        if (seg.direction) description += seg.direction;
        if (seg.curvature) description += ` ${seg.curvature}`;
      });
      
      if (state.connections.length > 0) {
        description += " with ";
        state.connections.forEach(conn => {
          description += `${conn.type} connection at ${conn.at}, `;
        });
      }
      
      if (state.asymptotes.length > 0) {
        description += " and ";
        state.asymptotes.forEach(asym => {
          description += `${asym.type} asymptote at ${asym.value}, `;
        });
      }
      
      const prompt = `Challenge: "${state.buildChallenge}"
${description}

Check if this matches. Consider that segments can be connected to form the required function.
Respond with "Correct!" or "Missing: [what's wrong]" in under 20 words.`;

      feedback.className = 'feedback info show';
      feedback.textContent = 'Checking...';
      
      try {
        const response = await fetch('/api/gemini', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ 
            contents: [{ 
              role: "user", 
              parts: [{ text: prompt }] 
            }] 
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          const result = data.candidates?.[0]?.content?.parts?.[0]?.text;
          
          if (result) {
            if (result.toLowerCase().includes('correct')) {
              feedback.className = 'feedback success show';
            } else {
              feedback.className = 'feedback error show';
            }
            feedback.textContent = result;
          }
        }
      } catch (error) {
        feedback.className = 'feedback info show';
        feedback.textContent = 'AI unavailable. Check if your function matches the description.';
      }
    }

    // Tab switching
    function switchToTab(tabName) {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.tab === tabName) {
          btn.classList.add('active');
        }
      });
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      document.getElementById(tabName).classList.add('active');
      
      if (tabName === 'intro') {
        setTimeout(drawExamples, 50);
      } else if (tabName === 'read') {
        initializeReadTab();
      } else if (tabName === 'build') {
        setTimeout(() => {
          initializeVisualBehaviors();
          initializeConnectionCards();
          updateBuildGraph();
        }, 50);
      }
    }

    // Initialize
    window.addEventListener('DOMContentLoaded', () => {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          switchToTab(btn.dataset.tab);
        });
      });
      
      drawExamples();
      generateNewBuildChallenge();
    });
  </script>
</body>
</html>
